/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository https://github.com/Myriad-Dreamin/typst.ts/blob/main/packages/typst.ts
*/


// src/options.init.ts
var BeforeBuildSymbol = Symbol("beforeBuild");
function preloadRemoteFonts(fonts) {
  return async (_, { ref, builder }) => {
    await Promise.all(fonts.map((font) => ref.loadFont(builder, font)));
  };
}
function preloadSystemFonts({ byFamily }) {
  return async (_, { builder }) => {
    const t = performance.now();
    if ("queryLocalFonts" in window) {
      const fonts = await window.queryLocalFonts();
      byFamily = byFamily ?? [];
      for (const font of fonts) {
        if (!byFamily.includes(font.family)) {
          continue;
        }
        const data = await (await font.blob()).arrayBuffer();
        await builder.add_raw_font(new Uint8Array(data));
      }
    }
    const t2 = performance.now();
    console.log("preload system font time used:", t2 - t);
  };
}
function withAccessModel(accessModel) {
  return async (_, { builder }) => {
    return new Promise((resolve) => {
      builder.set_access_model(
        accessModel,
        (path) => {
          const lastModified = accessModel.getMTime(path);
          if (lastModified) {
            return lastModified.getTime();
          }
          return 0;
        },
        (path) => {
          return accessModel.isFile(path) || false;
        },
        (path) => {
          return accessModel.getRealPath(path) || path;
        },
        (path) => {
          return accessModel.readAll(path);
        }
      );
      resolve();
    });
  };
}

// node_modules/@myriaddreamin/typst-ts-renderer/typst_ts_renderer.js
var wasm;
var heap = new Array(128).fill(void 0);
heap.push(void 0, null, true, false);
function getObject(idx) {
  return heap[idx];
}
var heap_next = heap.length;
function dropObject(idx) {
  if (idx < 132)
    return;
  heap[idx] = heap_next;
  heap_next = idx;
}
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
var cachedTextDecoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
if (typeof TextDecoder !== "undefined") {
  cachedTextDecoder.decode();
}
var cachedUint8Memory0 = null;
function getUint8Memory0() {
  if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
    cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
  }
  return cachedUint8Memory0;
}
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}
function addHeapObject(obj) {
  if (heap_next === heap.length)
    heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj;
  return idx;
}
var WASM_VECTOR_LEN = 0;
var cachedTextEncoder = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : { encode: () => {
  throw Error("TextEncoder not available");
} };
var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8Memory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127)
      break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
function isLikeNone(x) {
  return x === void 0 || x === null;
}
var cachedInt32Memory0 = null;
function getInt32Memory0() {
  if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
    cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
  }
  return cachedInt32Memory0;
}
var cachedFloat64Memory0 = null;
function getFloat64Memory0() {
  if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {
    cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);
  }
  return cachedFloat64Memory0;
}
function debugString(val) {
  const type = typeof val;
  if (type == "number" || type == "boolean" || val == null) {
    return `${val}`;
  }
  if (type == "string") {
    return `"${val}"`;
  }
  if (type == "symbol") {
    const description = val.description;
    if (description == null) {
      return "Symbol";
    } else {
      return `Symbol(${description})`;
    }
  }
  if (type == "function") {
    const name = val.name;
    if (typeof name == "string" && name.length > 0) {
      return `Function(${name})`;
    } else {
      return "Function";
    }
  }
  if (Array.isArray(val)) {
    const length = val.length;
    let debug = "[";
    if (length > 0) {
      debug += debugString(val[0]);
    }
    for (let i = 1; i < length; i++) {
      debug += ", " + debugString(val[i]);
    }
    debug += "]";
    return debug;
  }
  const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
  let className;
  if (builtInMatches.length > 1) {
    className = builtInMatches[1];
  } else {
    return toString.call(val);
  }
  if (className == "Object") {
    try {
      return "Object(" + JSON.stringify(val) + ")";
    } catch (_) {
      return "Object";
    }
  }
  if (val instanceof Error) {
    return `${val.name}: ${val.message}
${val.stack}`;
  }
  return className;
}
var cachedBigInt64Memory0 = null;
function getBigInt64Memory0() {
  if (cachedBigInt64Memory0 === null || cachedBigInt64Memory0.byteLength === 0) {
    cachedBigInt64Memory0 = new BigInt64Array(wasm.memory.buffer);
  }
  return cachedBigInt64Memory0;
}
function makeClosure(arg0, arg1, dtor, f) {
  const state = { a: arg0, b: arg1, cnt: 1, dtor };
  const real = (...args) => {
    state.cnt++;
    try {
      return f(state.a, state.b, ...args);
    } finally {
      if (--state.cnt === 0) {
        wasm.__wbindgen_export_2.get(state.dtor)(state.a, state.b);
        state.a = 0;
      }
    }
  };
  real.original = state;
  return real;
}
function __wbg_adapter_50(arg0, arg1, arg2) {
  wasm.wasm_bindgen__convert__closures__invoke1__h2df1f95f592dab86(arg0, arg1, addHeapObject(arg2));
}
function __wbg_adapter_53(arg0, arg1) {
  wasm._dyn_core__ops__function__Fn_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h01aa88e3d399a7bb(arg0, arg1);
}
function makeMutClosure(arg0, arg1, dtor, f) {
  const state = { a: arg0, b: arg1, cnt: 1, dtor };
  const real = (...args) => {
    state.cnt++;
    const a = state.a;
    state.a = 0;
    try {
      return f(a, state.b, ...args);
    } finally {
      if (--state.cnt === 0) {
        wasm.__wbindgen_export_2.get(state.dtor)(a, state.b);
      } else {
        state.a = a;
      }
    }
  };
  real.original = state;
  return real;
}
function __wbg_adapter_56(arg0, arg1, arg2) {
  wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hb7f09853f668c845(arg0, arg1, addHeapObject(arg2));
}
function handleError(f, args) {
  try {
    return f.apply(this, args);
  } catch (e) {
    wasm.__wbindgen_exn_store(addHeapObject(e));
  }
}
function __wbg_adapter_103(arg0, arg1, arg2, arg3) {
  wasm.wasm_bindgen__convert__closures__invoke2_mut__h6a919be76ec7d44b(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));
}
function notDefined(what) {
  return () => {
    throw new Error(`${what} is not defined`);
  };
}
function renderer_build_info() {
  const ret = wasm.renderer_build_info();
  return takeObject(ret);
}
function passArray8ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 1, 1) >>> 0;
  getUint8Memory0().set(arg, ptr / 1);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}
var cachedUint32Memory0 = null;
function getUint32Memory0() {
  if (cachedUint32Memory0 === null || cachedUint32Memory0.byteLength === 0) {
    cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);
  }
  return cachedUint32Memory0;
}
function passArray32ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 4, 4) >>> 0;
  getUint32Memory0().set(arg, ptr / 4);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}
function _assertClass(instance, klass) {
  if (!(instance instanceof klass)) {
    throw new Error(`expected instance of ${klass.name}`);
  }
  return instance.ptr;
}
var cachedFloat32Memory0 = null;
function getFloat32Memory0() {
  if (cachedFloat32Memory0 === null || cachedFloat32Memory0.byteLength === 0) {
    cachedFloat32Memory0 = new Float32Array(wasm.memory.buffer);
  }
  return cachedFloat32Memory0;
}
var PageInfo = class {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(PageInfo.prototype);
    obj.__wbg_ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_pageinfo_free(ptr);
  }
  /**
  * @returns {number}
  */
  get page_off() {
    const ret = wasm.pageinfo_page_off(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
  * @returns {number}
  */
  get width_pt() {
    const ret = wasm.pageinfo_width_pt(this.__wbg_ptr);
    return ret;
  }
  /**
  * @returns {number}
  */
  get height_pt() {
    const ret = wasm.pageinfo_height_pt(this.__wbg_ptr);
    return ret;
  }
};
var PagesInfo = class {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(PagesInfo.prototype);
    obj.__wbg_ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_pagesinfo_free(ptr);
  }
  /**
  * @returns {number}
  */
  get page_count() {
    const ret = wasm.pagesinfo_page_count(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
  * @param {number} num
  * @returns {PageInfo | undefined}
  */
  page_by_number(num) {
    const ret = wasm.pagesinfo_page_by_number(this.__wbg_ptr, num);
    return ret === 0 ? void 0 : PageInfo.__wrap(ret);
  }
  /**
  * @param {number} i
  * @returns {PageInfo}
  */
  page(i) {
    const ret = wasm.pagesinfo_page(this.__wbg_ptr, i);
    return PageInfo.__wrap(ret);
  }
};
var RenderPageImageOptions = class {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(RenderPageImageOptions.prototype);
    obj.__wbg_ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_renderpageimageoptions_free(ptr);
  }
  /**
  */
  constructor() {
    const ret = wasm.renderpageimageoptions_new();
    return RenderPageImageOptions.__wrap(ret);
  }
  /**
  * @returns {number}
  */
  get page_off() {
    const ret = wasm.renderpageimageoptions_page_off(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
  * @param {number} page_off
  */
  set page_off(page_off) {
    wasm.renderpageimageoptions_set_page_off(this.__wbg_ptr, page_off);
  }
};
var RenderSession = class {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(RenderSession.prototype);
    obj.__wbg_ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_rendersession_free(ptr);
  }
  /**
  * @returns {number}
  */
  get pixel_per_pt() {
    const ret = wasm.rendersession_pixel_per_pt(this.__wbg_ptr);
    return ret;
  }
  /**
  * @returns {string}
  */
  get background_color() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.rendersession_background_color(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
  * @returns {PagesInfo}
  */
  get pages_info() {
    const ret = wasm.rendersession_pages_info(this.__wbg_ptr);
    return PagesInfo.__wrap(ret);
  }
};
var RenderSessionOptions = class {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(RenderSessionOptions.prototype);
    obj.__wbg_ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_rendersessionoptions_free(ptr);
  }
  /**
  */
  constructor() {
    const ret = wasm.rendersessionoptions_new();
    return RenderSessionOptions.__wrap(ret);
  }
  /**
  * @returns {number | undefined}
  */
  get pixel_per_pt() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.rendersessionoptions_pixel_per_pt(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getFloat32Memory0()[retptr / 4 + 1];
      return r0 === 0 ? void 0 : r1;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * @param {number} pixel_per_pt
  */
  set pixel_per_pt(pixel_per_pt) {
    wasm.rendersessionoptions_set_pixel_per_pt(this.__wbg_ptr, pixel_per_pt);
  }
  /**
  * @returns {string | undefined}
  */
  get background_color() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.rendersessionoptions_background_color(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      let v1;
      if (r0 !== 0) {
        v1 = getStringFromWasm0(r0, r1).slice();
        wasm.__wbindgen_free(r0, r1 * 1);
      }
      return v1;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * @param {string} background_color
  */
  set background_color(background_color) {
    const ptr0 = passStringToWasm0(background_color, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    wasm.rendersessionoptions_set_background_color(this.__wbg_ptr, ptr0, len0);
  }
  /**
  * @returns {string | undefined}
  */
  get format() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.rendersessionoptions_format(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      let v1;
      if (r0 !== 0) {
        v1 = getStringFromWasm0(r0, r1).slice();
        wasm.__wbindgen_free(r0, r1 * 1);
      }
      return v1;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * @param {string} format
  */
  set format(format) {
    const ptr0 = passStringToWasm0(format, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN;
    wasm.rendersessionoptions_set_format(this.__wbg_ptr, ptr0, len0);
  }
};
var SvgSession = class {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(SvgSession.prototype);
    obj.__wbg_ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_svgsession_free(ptr);
  }
  /**
  */
  reset() {
    wasm.svgsession_reset(this.__wbg_ptr);
  }
  /**
  * @returns {number}
  */
  get doc_width() {
    const ret = wasm.svgsession_doc_width(this.__wbg_ptr);
    return ret;
  }
  /**
  * @returns {number}
  */
  get doc_height() {
    const ret = wasm.svgsession_doc_height(this.__wbg_ptr);
    return ret;
  }
  /**
  * @param {Uint8Array} delta
  */
  merge_delta(delta) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0(delta, wasm.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN;
      wasm.svgsession_merge_delta(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      if (r1) {
        throw takeObject(r0);
      }
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * @param {number} rect_lo_x
  * @param {number} rect_lo_y
  * @param {number} rect_hi_x
  * @param {number} rect_hi_y
  * @returns {string}
  */
  render_in_window(rect_lo_x, rect_lo_y, rect_hi_x, rect_hi_y) {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.svgsession_render_in_window(retptr, this.__wbg_ptr, rect_lo_x, rect_lo_y, rect_hi_x, rect_hi_y);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0(r0, r1);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
      wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
  * @param {Uint32Array} path
  * @returns {string | undefined}
  */
  get_source_loc(path) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray32ToWasm0(path, wasm.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN;
      wasm.svgsession_get_source_loc(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      var r3 = getInt32Memory0()[retptr / 4 + 3];
      if (r3) {
        throw takeObject(r2);
      }
      let v2;
      if (r0 !== 0) {
        v2 = getStringFromWasm0(r0, r1).slice();
        wasm.__wbindgen_free(r0, r1 * 1);
      }
      return v2;
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
};
var TypstRenderer = class {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(TypstRenderer.prototype);
    obj.__wbg_ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_typstrenderer_free(ptr);
  }
  /**
  * @param {Uint8Array} artifact_content
  * @param {RenderSessionOptions | undefined} options
  * @returns {RenderSession}
  */
  create_session(artifact_content, options) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0(artifact_content, wasm.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN;
      let ptr1 = 0;
      if (!isLikeNone(options)) {
        _assertClass(options, RenderSessionOptions);
        ptr1 = options.__destroy_into_raw();
      }
      wasm.typstrenderer_create_session(retptr, this.__wbg_ptr, ptr0, len0, ptr1);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return RenderSession.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * @param {Uint8Array} artifact_content
  * @returns {SvgSession}
  */
  create_svg_session(artifact_content) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0(artifact_content, wasm.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN;
      wasm.typstrenderer_create_svg_session(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return SvgSession.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * @returns {SvgSession}
  */
  create_empty_svg_session() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.typstrenderer_create_empty_svg_session(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return SvgSession.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * @param {SvgSession} session
  * @param {HTMLDivElement} root
  */
  render_svg(session, root) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      _assertClass(session, SvgSession);
      wasm.typstrenderer_render_svg(retptr, this.__wbg_ptr, session.__wbg_ptr, addHeapObject(root));
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      if (r1) {
        throw takeObject(r0);
      }
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * @param {RenderSession} session
  * @param {number} page_number
  * @param {string} page_content
  */
  load_page(session, page_number, page_content) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      _assertClass(session, RenderSession);
      const ptr0 = passStringToWasm0(page_content, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN;
      wasm.typstrenderer_load_page(retptr, this.__wbg_ptr, session.__wbg_ptr, page_number, ptr0, len0);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      if (r1) {
        throw takeObject(r0);
      }
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * @param {RenderSession} ses
  * @param {CanvasRenderingContext2D} canvas
  * @param {RenderPageImageOptions | undefined} options
  * @returns {Promise<any>}
  */
  render_page_to_canvas(ses, canvas, options) {
    _assertClass(ses, RenderSession);
    let ptr0 = 0;
    if (!isLikeNone(options)) {
      _assertClass(options, RenderPageImageOptions);
      ptr0 = options.__destroy_into_raw();
    }
    const ret = wasm.typstrenderer_render_page_to_canvas(this.__wbg_ptr, ses.__wbg_ptr, addHeapObject(canvas), ptr0);
    return takeObject(ret);
  }
  /**
  * @param {any} v
  */
  load_glyph_pack(v) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.typstrenderer_load_glyph_pack(retptr, this.__wbg_ptr, addHeapObject(v));
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      if (r1) {
        throw takeObject(r0);
      }
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * @param {Uint8Array} artifact_content
  * @returns {Uint8Array}
  */
  render_to_pdf(artifact_content) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0(artifact_content, wasm.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN;
      wasm.typstrenderer_render_to_pdf(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * @param {RenderSession} session
  * @returns {Uint8Array}
  */
  render_to_pdf_in_session(session) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      _assertClass(session, RenderSession);
      wasm.typstrenderer_render_to_pdf_in_session(retptr, this.__wbg_ptr, session.__wbg_ptr);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * @param {RenderSession} _session
  * @param {RenderPageImageOptions | undefined} _options
  * @returns {ImageData}
  */
  render_page(_session, _options) {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      _assertClass(_session, RenderSession);
      let ptr0 = 0;
      if (!isLikeNone(_options)) {
        _assertClass(_options, RenderPageImageOptions);
        ptr0 = _options.__destroy_into_raw();
      }
      wasm.typstrenderer_render_page(retptr, this.__wbg_ptr, _session.__wbg_ptr, ptr0);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
};
var TypstRendererBuilder = class {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(TypstRendererBuilder.prototype);
    obj.__wbg_ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm.__wbg_typstrendererbuilder_free(ptr);
  }
  /**
  * @param {any} pack
  * @returns {Promise<void>}
  */
  add_glyph_pack(pack) {
    const ret = wasm.typstrendererbuilder_add_glyph_pack(this.__wbg_ptr, addHeapObject(pack));
    return takeObject(ret);
  }
  /**
  * @param {Uint8Array} font_buffer
  * @returns {Promise<void>}
  */
  add_raw_font(font_buffer) {
    const ret = wasm.typstrendererbuilder_add_raw_font(this.__wbg_ptr, addHeapObject(font_buffer));
    return takeObject(ret);
  }
  /**
  * @param {Array<any>} font
  * @returns {Promise<void>}
  */
  add_web_fonts(font) {
    const ret = wasm.typstrendererbuilder_add_web_fonts(this.__wbg_ptr, addHeapObject(font));
    return takeObject(ret);
  }
  /**
  */
  constructor() {
    try {
      const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
      wasm.typstrendererbuilder_new(retptr);
      var r0 = getInt32Memory0()[retptr / 4 + 0];
      var r1 = getInt32Memory0()[retptr / 4 + 1];
      var r2 = getInt32Memory0()[retptr / 4 + 2];
      if (r2) {
        throw takeObject(r1);
      }
      return TypstRendererBuilder.__wrap(r0);
    } finally {
      wasm.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * @returns {Promise<TypstRenderer>}
  */
  build() {
    const ptr = this.__destroy_into_raw();
    const ret = wasm.typstrendererbuilder_build(ptr);
    return takeObject(ret);
  }
};
async function __wbg_load(module, imports) {
  if (typeof Response === "function" && module instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module, imports);
      } catch (e) {
        if (module.headers.get("Content-Type") != "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
        } else {
          throw e;
        }
      }
    }
    const bytes = await module.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module };
    } else {
      return instance;
    }
  }
}
function __wbg_get_imports() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbg_new_abda76e883ba8a5f = function() {
    const ret = new Error();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) {
    const ret = getObject(arg1).stack;
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) {
    let deferred0_0;
    let deferred0_1;
    try {
      deferred0_0 = arg0;
      deferred0_1 = arg1;
      console.error(getStringFromWasm0(arg0, arg1));
    } finally {
      wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);
    }
  };
  imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
    takeObject(arg0);
  };
  imports.wbg.__wbg_get_44be0491f933a435 = function(arg0, arg1) {
    const ret = getObject(arg0)[arg1 >>> 0];
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_length_fff51ee6522a1a18 = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
  };
  imports.wbg.__wbindgen_is_object = function(arg0) {
    const val = getObject(arg0);
    const ret = typeof val === "object" && val !== null;
    return ret;
  };
  imports.wbg.__wbg_next_526fc47e980da008 = function(arg0) {
    const ret = getObject(arg0).next;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_is_function = function(arg0) {
    const ret = typeof getObject(arg0) === "function";
    return ret;
  };
  imports.wbg.__wbg_next_ddb3312ca1c4e32a = function() {
    return handleError(function(arg0) {
      const ret = getObject(arg0).next();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_done_5c1f01fb660d73b5 = function(arg0) {
    const ret = getObject(arg0).done;
    return ret;
  };
  imports.wbg.__wbg_value_1695675138684bd5 = function(arg0) {
    const ret = getObject(arg0).value;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_iterator_97f0c81209c6c35a = function() {
    const ret = Symbol.iterator;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_get_97b561fb56f034b5 = function() {
    return handleError(function(arg0, arg1) {
      const ret = Reflect.get(getObject(arg0), getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_call_cb65541d95d71282 = function() {
    return handleError(function(arg0, arg1) {
      const ret = getObject(arg0).call(getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm0(arg0, arg1);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_object_clone_ref = function(arg0) {
    const ret = getObject(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_self_1ff1d729e9aae938 = function() {
    return handleError(function() {
      const ret = self.self;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_window_5f4faef6c12b79ec = function() {
    return handleError(function() {
      const ret = window.window;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_globalThis_1d39714405582d3c = function() {
    return handleError(function() {
      const ret = globalThis.globalThis;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_global_651f05c6a0944d1c = function() {
    return handleError(function() {
      const ret = global.global;
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbindgen_is_undefined = function(arg0) {
    const ret = getObject(arg0) === void 0;
    return ret;
  };
  imports.wbg.__wbg_newnoargs_581967eacc0e2604 = function(arg0, arg1) {
    const ret = new Function(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_898a68150f225f2e = function() {
    const ret = new Array();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_set_502d29070ea18557 = function(arg0, arg1, arg2) {
    getObject(arg0)[arg1 >>> 0] = takeObject(arg2);
  };
  imports.wbg.__wbg_isArray_4c24b343cb13cfb1 = function(arg0) {
    const ret = Array.isArray(getObject(arg0));
    return ret;
  };
  imports.wbg.__wbg_push_ca1c26067ef907ac = function(arg0, arg1) {
    const ret = getObject(arg0).push(getObject(arg1));
    return ret;
  };
  imports.wbg.__wbg_instanceof_ArrayBuffer_39ac22089b74fddb = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof ArrayBuffer;
    } catch {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_new_d258248ed531ff54 = function(arg0, arg1) {
    const ret = new Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_call_01734de55d61e11d = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_isSafeInteger_bb8e18dd21c97288 = function(arg0) {
    const ret = Number.isSafeInteger(getObject(arg0));
    return ret;
  };
  imports.wbg.__wbg_instanceof_Object_3daa8298c86298be = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Object;
    } catch {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_entries_e51f29c7bba0c054 = function(arg0) {
    const ret = Object.entries(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_b51585de1b234aff = function() {
    const ret = new Object();
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_43f1b47c28813cbd = function(arg0, arg1) {
    try {
      var state0 = { a: arg0, b: arg1 };
      var cb0 = (arg02, arg12) => {
        const a = state0.a;
        state0.a = 0;
        try {
          return __wbg_adapter_103(a, state0.b, arg02, arg12);
        } finally {
          state0.a = a;
        }
      };
      const ret = new Promise(cb0);
      return addHeapObject(ret);
    } finally {
      state0.a = state0.b = 0;
    }
  };
  imports.wbg.__wbg_resolve_53698b95aaf7fcf8 = function(arg0) {
    const ret = Promise.resolve(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_then_f7e06ee3c11698eb = function(arg0, arg1) {
    const ret = getObject(arg0).then(getObject(arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_then_b2267541e2a73865 = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).then(getObject(arg1), getObject(arg2));
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_memory = function() {
    const ret = wasm.memory;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_buffer_085ec1f694018c4f = function(arg0) {
    const ret = getObject(arg0).buffer;
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_new_8125e318e6245eed = function(arg0) {
    const ret = new Uint8Array(getObject(arg0));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_set_5cf90238115182c3 = function(arg0, arg1, arg2) {
    getObject(arg0).set(getObject(arg1), arg2 >>> 0);
  };
  imports.wbg.__wbg_length_72e2208bbc0efc61 = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
  };
  imports.wbg.__wbg_newwithbyteoffsetandlength_6da8e527659b86aa = function(arg0, arg1, arg2) {
    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_instanceof_Uint8Array_d8d9cb2b8e8ac1d4 = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Uint8Array;
    } catch {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_newwithlength_e5d69174d6984cd7 = function(arg0) {
    const ret = new Uint8Array(arg0 >>> 0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_string_get = function(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof obj === "string" ? obj : void 0;
    var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbg_set_092e06b0f9d71865 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = Reflect.set(getObject(arg0), getObject(arg1), getObject(arg2));
      return ret;
    }, arguments);
  };
  imports.wbg.__wbg_random_5f61cd0d6777a993 = typeof Math.random == "function" ? Math.random : notDefined("Math.random");
  imports.wbg.__wbg_parse_670c19d4e984792e = function() {
    return handleError(function(arg0, arg1) {
      const ret = JSON.parse(getStringFromWasm0(arg0, arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_stringify_e25465938f3f611f = function() {
    return handleError(function(arg0) {
      const ret = JSON.stringify(getObject(arg0));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbindgen_number_new = function(arg0) {
    const ret = arg0;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_jsval_loose_eq = function(arg0, arg1) {
    const ret = getObject(arg0) == getObject(arg1);
    return ret;
  };
  imports.wbg.__wbindgen_boolean_get = function(arg0) {
    const v = getObject(arg0);
    const ret = typeof v === "boolean" ? v ? 1 : 0 : 2;
    return ret;
  };
  imports.wbg.__wbindgen_number_get = function(arg0, arg1) {
    const obj = getObject(arg1);
    const ret = typeof obj === "number" ? obj : void 0;
    getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;
    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);
  };
  imports.wbg.__wbg_String_88810dfeb4021902 = function(arg0, arg1) {
    const ret = String(getObject(arg1));
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbindgen_error_new = function(arg0, arg1) {
    const ret = new Error(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_getwithrefkey_5e6d9547403deab8 = function(arg0, arg1) {
    const ret = getObject(arg0)[getObject(arg1)];
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_set_841ac57cff3d672b = function(arg0, arg1, arg2) {
    getObject(arg0)[takeObject(arg1)] = takeObject(arg2);
  };
  imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {
    const ret = debugString(getObject(arg1));
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbg_warn_fb2e68e6e02a4cb1 = function(arg0, arg1) {
    console.warn(getObject(arg0), getObject(arg1));
  };
  imports.wbg.__wbg_info_2e30e8204b29d91d = function(arg0) {
    console.info(getObject(arg0));
  };
  imports.wbg.__wbg_instanceof_HtmlImageElement_7654818e144eb606 = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof HTMLImageElement;
    } catch {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_instanceof_Window_9029196b662bc42a = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Window;
    } catch {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_document_f7ace2b956f30a4f = function(arg0) {
    const ret = getObject(arg0).document;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_createElement_4891554b28d3388b = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).createElement(getStringFromWasm0(arg1, arg2));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_new_f648bc7adcace0bc = function() {
    return handleError(function() {
      const ret = new DOMParser();
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_parseFromString_3d7be3de8b4c264e = function() {
    return handleError(function(arg0, arg1, arg2, arg3) {
      const ret = getObject(arg0).parseFromString(getStringFromWasm0(arg1, arg2), takeObject(arg3));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_querySelector_52ded52c20e23921 = function() {
    return handleError(function(arg0, arg1, arg2) {
      const ret = getObject(arg0).querySelector(getStringFromWasm0(arg1, arg2));
      return isLikeNone(ret) ? 0 : addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_getElementsByTagName_f5ac50391c7f853c = function(arg0, arg1, arg2) {
    const ret = getObject(arg0).getElementsByTagName(getStringFromWasm0(arg1, arg2));
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_length_b37ae9be90ea7cf5 = function(arg0) {
    const ret = getObject(arg0).length;
    return ret;
  };
  imports.wbg.__wbg_firstChild_08ce7a229cc70a39 = function(arg0) {
    const ret = getObject(arg0).firstChild;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_instanceof_Element_4622f5da1249a3eb = function(arg0) {
    let result;
    try {
      result = getObject(arg0) instanceof Element;
    } catch {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_getAttribute_3d8fcc9eaea35a17 = function(arg0, arg1, arg2, arg3) {
    const ret = getObject(arg1).getAttribute(getStringFromWasm0(arg2, arg3));
    var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbg_outerHTML_f7749ceff37b5832 = function(arg0, arg1) {
    const ret = getObject(arg1).outerHTML;
    const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN;
    getInt32Memory0()[arg0 / 4 + 1] = len1;
    getInt32Memory0()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbg_newwithpathstring_8dbb7720cd8901d4 = function() {
    return handleError(function(arg0, arg1) {
      const ret = new Path2D(getStringFromWasm0(arg0, arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_save_cdcca9591f027e80 = function(arg0) {
    getObject(arg0).save();
  };
  imports.wbg.__wbg_restore_890c3582852dbadf = function(arg0) {
    getObject(arg0).restore();
  };
  imports.wbg.__wbg_now_0cfdc90c97d0c24b = function(arg0) {
    const ret = getObject(arg0).now();
    return ret;
  };
  imports.wbg.__wbindgen_is_bigint = function(arg0) {
    const ret = typeof getObject(arg0) === "bigint";
    return ret;
  };
  imports.wbg.__wbindgen_bigint_get_as_i64 = function(arg0, arg1) {
    const v = getObject(arg1);
    const ret = typeof v === "bigint" ? v : void 0;
    getBigInt64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? BigInt(0) : ret;
    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);
  };
  imports.wbg.__wbindgen_bigint_from_i64 = function(arg0) {
    const ret = arg0;
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_jsval_eq = function(arg0, arg1) {
    const ret = getObject(arg0) === getObject(arg1);
    return ret;
  };
  imports.wbg.__wbindgen_in = function(arg0, arg1) {
    const ret = getObject(arg0) in getObject(arg1);
    return ret;
  };
  imports.wbg.__wbindgen_bigint_from_u64 = function(arg0) {
    const ret = BigInt.asUintN(64, arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_is_string = function(arg0) {
    const ret = typeof getObject(arg0) === "string";
    return ret;
  };
  imports.wbg.__wbg_log_4c205e6fbb25f8c3 = function(arg0, arg1, arg2) {
    console.log(getObject(arg0), getObject(arg1), getObject(arg2));
  };
  imports.wbg.__wbindgen_is_null = function(arg0) {
    const ret = getObject(arg0) === null;
    return ret;
  };
  imports.wbg.__wbg_typstrenderer_new = function(arg0) {
    const ret = TypstRenderer.__wrap(arg0);
    return addHeapObject(ret);
  };
  imports.wbg.__wbg_clientWidth_51ec21e3189f5656 = function(arg0) {
    const ret = getObject(arg0).clientWidth;
    return ret;
  };
  imports.wbg.__wbg_setinnerHTML_b089587252408b67 = function(arg0, arg1, arg2) {
    getObject(arg0).innerHTML = getStringFromWasm0(arg1, arg2);
  };
  imports.wbg.__wbg_log_1d3ae0273d8f4f8a = function(arg0) {
    console.log(getObject(arg0));
  };
  imports.wbg.__wbg_firstElementChild_56b7412091945a7f = function(arg0) {
    const ret = getObject(arg0).firstElementChild;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_setAttribute_e7e80b478b7b8b2f = function() {
    return handleError(function(arg0, arg1, arg2, arg3, arg4) {
      getObject(arg0).setAttribute(getStringFromWasm0(arg1, arg2), getStringFromWasm0(arg3, arg4));
    }, arguments);
  };
  imports.wbg.__wbg_setfillStyle_401fa583a1c8863c = function(arg0, arg1) {
    getObject(arg0).fillStyle = getObject(arg1);
  };
  imports.wbg.__wbg_fillRect_e285f7b46668b7fa = function(arg0, arg1, arg2, arg3, arg4) {
    getObject(arg0).fillRect(arg1, arg2, arg3, arg4);
  };
  imports.wbg.__wbg_revokeObjectURL_571395bdb196a1de = function() {
    return handleError(function(arg0, arg1) {
      URL.revokeObjectURL(getStringFromWasm0(arg0, arg1));
    }, arguments);
  };
  imports.wbg.__wbindgen_cb_drop = function(arg0) {
    const obj = takeObject(arg0).original;
    if (obj.cnt-- == 1) {
      obj.a = 0;
      return true;
    }
    const ret = false;
    return ret;
  };
  imports.wbg.__wbg_setTransform_39caea5e97b29f2e = function() {
    return handleError(function(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
      getObject(arg0).setTransform(arg1, arg2, arg3, arg4, arg5, arg6);
    }, arguments);
  };
  imports.wbg.__wbg_beginPath_b3943a4f4af02eac = function(arg0) {
    getObject(arg0).beginPath();
  };
  imports.wbg.__wbg_fill_4fbbfcd27461f1e6 = function(arg0, arg1) {
    getObject(arg0).fill(getObject(arg1));
  };
  imports.wbg.__wbg_resetTransform_8427c5468207dba3 = function() {
    return handleError(function(arg0) {
      getObject(arg0).resetTransform();
    }, arguments);
  };
  imports.wbg.__wbg_transform_c9f55f741f6615bf = function() {
    return handleError(function(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
      getObject(arg0).transform(arg1, arg2, arg3, arg4, arg5, arg6);
    }, arguments);
  };
  imports.wbg.__wbg_setlineDashOffset_f37f4ea2fc9ddee1 = function(arg0, arg1) {
    getObject(arg0).lineDashOffset = arg1;
  };
  imports.wbg.__wbg_setLineDash_ffd4b25a7a33e57b = function() {
    return handleError(function(arg0, arg1) {
      getObject(arg0).setLineDash(getObject(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_setlineWidth_6cbd15cb2b4ab14b = function(arg0, arg1) {
    getObject(arg0).lineWidth = arg1;
  };
  imports.wbg.__wbg_setlineCap_6ebf29df37947b53 = function(arg0, arg1, arg2) {
    getObject(arg0).lineCap = getStringFromWasm0(arg1, arg2);
  };
  imports.wbg.__wbg_setlineJoin_eccaea89d57fb044 = function(arg0, arg1, arg2) {
    getObject(arg0).lineJoin = getStringFromWasm0(arg1, arg2);
  };
  imports.wbg.__wbg_setmiterLimit_50d0d46f19e3054f = function(arg0, arg1) {
    getObject(arg0).miterLimit = arg1;
  };
  imports.wbg.__wbg_setstrokeStyle_3fe4d1c0d11ed1b6 = function(arg0, arg1) {
    getObject(arg0).strokeStyle = getObject(arg1);
  };
  imports.wbg.__wbg_stroke_c4647eb26598b90b = function(arg0, arg1) {
    getObject(arg0).stroke(getObject(arg1));
  };
  imports.wbg.__wbg_clip_aa52b99fb9d275fb = function(arg0, arg1) {
    getObject(arg0).clip(getObject(arg1));
  };
  imports.wbg.__wbg_canvas_d018466af7372650 = function(arg0) {
    const ret = getObject(arg0).canvas;
    return isLikeNone(ret) ? 0 : addHeapObject(ret);
  };
  imports.wbg.__wbg_newwithu8arraysequenceandoptions_854056d2c35b489c = function() {
    return handleError(function(arg0, arg1) {
      const ret = new Blob(getObject(arg0), getObject(arg1));
      return addHeapObject(ret);
    }, arguments);
  };
  imports.wbg.__wbg_createObjectURL_d82f2880bada6a1d = function() {
    return handleError(function(arg0, arg1) {
      const ret = URL.createObjectURL(getObject(arg1));
      const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len1 = WASM_VECTOR_LEN;
      getInt32Memory0()[arg0 / 4 + 1] = len1;
      getInt32Memory0()[arg0 / 4 + 0] = ptr1;
    }, arguments);
  };
  imports.wbg.__wbg_drawImage_91b0b71585865ad1 = function() {
    return handleError(function(arg0, arg1, arg2, arg3, arg4, arg5) {
      getObject(arg0).drawImage(getObject(arg1), arg2, arg3, arg4, arg5);
    }, arguments);
  };
  imports.wbg.__wbg_setsrc_fac5b9516fc69301 = function(arg0, arg1, arg2) {
    getObject(arg0).src = getStringFromWasm0(arg1, arg2);
  };
  imports.wbg.__wbg_setonload_b4f5d9b15b0ee9d3 = function(arg0, arg1) {
    getObject(arg0).onload = getObject(arg1);
  };
  imports.wbg.__wbg_setonerror_acddd28c276005c1 = function(arg0, arg1) {
    getObject(arg0).onerror = getObject(arg1);
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0(arg0, arg1));
  };
  imports.wbg.__wbindgen_closure_wrapper2382 = function(arg0, arg1, arg2) {
    const ret = makeClosure(arg0, arg1, 769, __wbg_adapter_50);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper2383 = function(arg0, arg1, arg2) {
    const ret = makeClosure(arg0, arg1, 769, __wbg_adapter_53);
    return addHeapObject(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper2756 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure(arg0, arg1, 871, __wbg_adapter_56);
    return addHeapObject(ret);
  };
  return imports;
}
function __wbg_init_memory(imports, maybe_memory) {
}
function __wbg_finalize_init(instance, module) {
  wasm = instance.exports;
  __wbg_init.__wbindgen_wasm_module = module;
  cachedBigInt64Memory0 = null;
  cachedFloat32Memory0 = null;
  cachedFloat64Memory0 = null;
  cachedInt32Memory0 = null;
  cachedUint32Memory0 = null;
  cachedUint8Memory0 = null;
  return wasm;
}
async function __wbg_init(input) {
  if (wasm !== void 0)
    return wasm;
  if (typeof input === "undefined") {
    input = new URL("typst_ts_renderer_bg.wasm", import.meta.url);
  }
  const imports = __wbg_get_imports();
  if (typeof input === "string" || typeof Request === "function" && input instanceof Request || typeof URL === "function" && input instanceof URL) {
    input = fetch(input);
  }
  __wbg_init_memory(imports);
  const { instance, module } = await __wbg_load(await input, imports);
  return __wbg_finalize_init(instance, module);
}
var typst_ts_renderer_default = __wbg_init;

// src/options.render.ts
var svgFormats = ["vector"];
function isRenderSvgOption(f) {
  return svgFormats.includes(f.format);
}

// src/viewport.ts
var PageViewport = class {
  constructor({
    viewBox,
    scale,
    rotation,
    offsetX = 0,
    offsetY = 0,
    dontFlip = false
  }) {
    this.viewBox = viewBox;
    this.scale = scale;
    this.rotation = rotation;
    this.offsetX = offsetX;
    this.offsetY = offsetY;
    const centerX = (viewBox[2] + viewBox[0]) / 2;
    const centerY = (viewBox[3] + viewBox[1]) / 2;
    let rotateA, rotateB, rotateC, rotateD;
    rotation %= 360;
    if (rotation < 0) {
      rotation += 360;
    }
    switch (rotation) {
      case 180:
        rotateA = -1;
        rotateB = 0;
        rotateC = 0;
        rotateD = 1;
        break;
      case 90:
        rotateA = 0;
        rotateB = 1;
        rotateC = 1;
        rotateD = 0;
        break;
      case 270:
        rotateA = 0;
        rotateB = -1;
        rotateC = -1;
        rotateD = 0;
        break;
      case 0:
        rotateA = 1;
        rotateB = 0;
        rotateC = 0;
        rotateD = -1;
        break;
      default:
        throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
    }
    if (dontFlip) {
      rotateC = -rotateC;
      rotateD = -rotateD;
    }
    let offsetCanvasX, offsetCanvasY;
    let width, height;
    if (rotateA === 0) {
      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
      width = (viewBox[3] - viewBox[1]) * scale;
      height = (viewBox[2] - viewBox[0]) * scale;
    } else {
      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
      width = (viewBox[2] - viewBox[0]) * scale;
      height = (viewBox[3] - viewBox[1]) * scale;
    }
    this.transform = [
      rotateA * scale,
      rotateB * scale,
      rotateC * scale,
      rotateD * scale,
      offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY,
      offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY
    ];
    this.width = width;
    this.height = height;
  }
  get rawDims() {
    const { viewBox } = this;
    return {
      // todo: shadow
      pageWidth: viewBox[2] - viewBox[0],
      pageHeight: viewBox[3] - viewBox[1],
      pageX: viewBox[0],
      pageY: viewBox[1]
    };
  }
  clone({
    scale = this.scale,
    rotation = this.rotation,
    offsetX = this.offsetX,
    offsetY = this.offsetY,
    dontFlip = false
  } = {}) {
    return new PageViewport({
      viewBox: this.viewBox.slice(),
      scale,
      rotation,
      offsetX,
      offsetY,
      dontFlip
    });
  }
  static applyTransform(p, m) {
    const xt = p[0] * m[0] + p[1] * m[2] + m[4];
    const yt = p[0] * m[1] + p[1] * m[3] + m[5];
    return [xt, yt];
  }
  static applyInverseTransform(p, m) {
    const d = m[0] * m[3] - m[1] * m[2];
    const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
    const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
    return [xt, yt];
  }
  convertToViewportPoint(x, y) {
    return PageViewport.applyTransform([x, y], this.transform);
  }
  convertToViewportRectangle(rect) {
    const topLeft = PageViewport.applyTransform([rect[0], rect[1]], this.transform);
    const bottomRight = PageViewport.applyTransform([rect[2], rect[3]], this.transform);
    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
  }
  convertToPdfPoint(x, y) {
    return PageViewport.applyInverseTransform([x, y], this.transform);
  }
};

// src/view.ts
var RenderView = class {
  constructor(pageInfos, container, options) {
    this.pageInfos = pageInfos;
    this.imageScaleFactor = options.pixelPerPt ?? 2;
    container.innerHTML = "";
    container.style.width = "100%";
    this.container = container;
    this.canvasList = new Array(this.loadPageCount);
    this.textLayerList = new Array(this.loadPageCount);
    this.commonList = new Array(this.loadPageCount);
    this.textLayerParentList = new Array(this.loadPageCount);
    this.annotationLayerList = new Array(this.loadPageCount);
    this.semanticLayerList = new Array(this.loadPageCount);
    const createOver = (i, width, height, commonDiv) => {
      const canvas = this.canvasList[i] = document.createElement("canvas");
      const semanticLayer = this.semanticLayerList[i] = document.createElement("div");
      const textLayer = this.textLayerList[i] = document.createElement("div");
      const textLayerParent = this.textLayerParentList[i] = document.createElement("div");
      const annotationLayer = this.annotationLayerList[i] = document.createElement("div");
      const ctx = canvas.getContext("2d");
      if (ctx) {
        const canvasDiv = document.createElement("div");
        canvas.width = width;
        canvas.height = height;
        canvasDiv.appendChild(canvas);
        commonDiv.appendChild(canvasDiv);
        canvasDiv.style.position = "absolute";
      }
      {
        textLayerParent.appendChild(textLayer);
        textLayerParent.className = "text-layer textLayer";
        const containerWidth = container.offsetWidth;
        const orignalScale = containerWidth / width;
        textLayerParent.style.width = `${containerWidth}px`;
        textLayerParent.style.height = `${height * orignalScale}px`;
        textLayerParent.style.position = "absolute";
        annotationLayer.style.width = `${containerWidth}px`;
        annotationLayer.style.height = `${height * orignalScale}px`;
        annotationLayer.style.position = "absolute";
        commonDiv.style.width = `${containerWidth}px`;
        commonDiv.style.height = `${height * orignalScale}px`;
        commonDiv.style.position = "relative";
        semanticLayer.appendChild(textLayerParent);
        semanticLayer.appendChild(annotationLayer);
        commonDiv.appendChild(semanticLayer);
      }
    };
    for (let i = 0; i < this.pageInfos.length; i++) {
      const pageAst = this.pageInfos[i];
      const width = Math.ceil(pageAst.width) * this.imageScaleFactor;
      const height = Math.ceil(pageAst.height) * this.imageScaleFactor;
      let commonDiv = void 0;
      commonDiv = this.commonList[i] = document.createElement("div");
      container.appendChild(commonDiv);
      createOver(i, width, height, commonDiv);
    }
  }
  resetLayout() {
    for (let i = 0; i < this.pageInfos.length; i++) {
      const pageAst = this.pageInfos[i];
      const width = Math.ceil(pageAst.width) * this.imageScaleFactor;
      const height = Math.ceil(pageAst.height) * this.imageScaleFactor;
      const canvasDiv = this.canvasList[i].parentElement;
      if (!canvasDiv) {
        throw new Error(
          `canvasDiv is null for page ${i}, canvas list length ${this.canvasList.length}`
        );
      }
      const commonDiv = this.commonList[i];
      const textLayerParent = this.textLayerParentList[i];
      const annotationLayer = this.annotationLayerList[i];
      const containerWidth = this.container.offsetWidth;
      const orignalScale = containerWidth / width;
      textLayerParent.style.width = `${containerWidth}px`;
      textLayerParent.style.height = `${height * orignalScale}px`;
      annotationLayer.style.width = `${containerWidth}px`;
      annotationLayer.style.height = `${height * orignalScale}px`;
      commonDiv.style.width = `${containerWidth}px`;
      commonDiv.style.height = `${height * orignalScale}px`;
      const currentScale = this.container.offsetWidth / width;
      canvasDiv.style.transformOrigin = "0px 0px";
      canvasDiv.style.transform = `scale(${currentScale})`;
    }
  }
};
function renderTextLayer(pdfjsLib, container, pageInfos, layerList, textSourceList) {
  const containerWidth = container.offsetWidth;
  const t2 = performance.now();
  const renderOne = (layer, i) => {
    const page_info = pageInfos[i];
    if (!page_info) {
      console.error("page not found for", i);
      return;
    }
    const width_pt = page_info.width;
    const height_pt = page_info.height;
    const orignalScale = containerWidth / width_pt;
    const scale = Number.parseFloat(orignalScale.toFixed(4));
    layer.parentElement?.style.setProperty("--scale-factor", scale.toString());
    const viewport = new PageViewport({
      viewBox: [0, 0, width_pt, height_pt],
      scale,
      offsetX: 0,
      offsetY: 0,
      rotation: 0,
      dontFlip: false
    });
    pdfjsLib.renderTextLayer({
      textContentSource: textSourceList[i],
      container: layer,
      viewport
    });
  };
  layerList.forEach(renderOne);
  const t3 = performance.now();
  console.log(`text layer used: render = ${(t3 - t2).toFixed(1)}ms`);
}

// src/wasm.ts
var once = (fn) => {
  let called = false;
  let res;
  return () => {
    if (called) {
      return res;
    }
    called = true;
    return res = fn();
  };
};
var LazyWasmModule = class {
  constructor(initFn) {
    if (typeof initFn !== "function") {
      throw new Error("initFn is not a function");
    }
    this.initOnce = once(async () => {
      await initFn(this.wasmBin);
    });
  }
  async init(module) {
    this.wasmBin = module;
    await this.initOnce();
  }
};

// ../compiler/pkg/typst_ts_web_compiler.js
var wasm2;
var heap2 = new Array(128).fill(void 0);
heap2.push(void 0, null, true, false);
function getObject2(idx) {
  return heap2[idx];
}
var heap_next2 = heap2.length;
function dropObject2(idx) {
  if (idx < 132)
    return;
  heap2[idx] = heap_next2;
  heap_next2 = idx;
}
function takeObject2(idx) {
  const ret = getObject2(idx);
  dropObject2(idx);
  return ret;
}
var cachedTextDecoder2 = typeof TextDecoder !== "undefined" ? new TextDecoder("utf-8", { ignoreBOM: true, fatal: true }) : { decode: () => {
  throw Error("TextDecoder not available");
} };
if (typeof TextDecoder !== "undefined") {
  cachedTextDecoder2.decode();
}
var cachedUint8Memory02 = null;
function getUint8Memory02() {
  if (cachedUint8Memory02 === null || cachedUint8Memory02.byteLength === 0) {
    cachedUint8Memory02 = new Uint8Array(wasm2.memory.buffer);
  }
  return cachedUint8Memory02;
}
function getStringFromWasm02(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder2.decode(getUint8Memory02().subarray(ptr, ptr + len));
}
function addHeapObject2(obj) {
  if (heap_next2 === heap2.length)
    heap2.push(heap2.length + 1);
  const idx = heap_next2;
  heap_next2 = heap2[idx];
  heap2[idx] = obj;
  return idx;
}
var WASM_VECTOR_LEN2 = 0;
var cachedTextEncoder2 = typeof TextEncoder !== "undefined" ? new TextEncoder("utf-8") : { encode: () => {
  throw Error("TextEncoder not available");
} };
var encodeString2 = typeof cachedTextEncoder2.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder2.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder2.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm02(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder2.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8Memory02().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN2 = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8Memory02();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127)
      break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8Memory02().subarray(ptr + offset, ptr + len);
    const ret = encodeString2(arg, view);
    offset += ret.written;
  }
  WASM_VECTOR_LEN2 = offset;
  return ptr;
}
function isLikeNone2(x) {
  return x === void 0 || x === null;
}
var cachedInt32Memory02 = null;
function getInt32Memory02() {
  if (cachedInt32Memory02 === null || cachedInt32Memory02.byteLength === 0) {
    cachedInt32Memory02 = new Int32Array(wasm2.memory.buffer);
  }
  return cachedInt32Memory02;
}
function debugString2(val) {
  const type = typeof val;
  if (type == "number" || type == "boolean" || val == null) {
    return `${val}`;
  }
  if (type == "string") {
    return `"${val}"`;
  }
  if (type == "symbol") {
    const description = val.description;
    if (description == null) {
      return "Symbol";
    } else {
      return `Symbol(${description})`;
    }
  }
  if (type == "function") {
    const name = val.name;
    if (typeof name == "string" && name.length > 0) {
      return `Function(${name})`;
    } else {
      return "Function";
    }
  }
  if (Array.isArray(val)) {
    const length = val.length;
    let debug = "[";
    if (length > 0) {
      debug += debugString2(val[0]);
    }
    for (let i = 1; i < length; i++) {
      debug += ", " + debugString2(val[i]);
    }
    debug += "]";
    return debug;
  }
  const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
  let className;
  if (builtInMatches.length > 1) {
    className = builtInMatches[1];
  } else {
    return toString.call(val);
  }
  if (className == "Object") {
    try {
      return "Object(" + JSON.stringify(val) + ")";
    } catch (_) {
      return "Object";
    }
  }
  if (val instanceof Error) {
    return `${val.name}: ${val.message}
${val.stack}`;
  }
  return className;
}
var cachedFloat64Memory02 = null;
function getFloat64Memory02() {
  if (cachedFloat64Memory02 === null || cachedFloat64Memory02.byteLength === 0) {
    cachedFloat64Memory02 = new Float64Array(wasm2.memory.buffer);
  }
  return cachedFloat64Memory02;
}
var cachedBigInt64Memory02 = null;
function getBigInt64Memory02() {
  if (cachedBigInt64Memory02 === null || cachedBigInt64Memory02.byteLength === 0) {
    cachedBigInt64Memory02 = new BigInt64Array(wasm2.memory.buffer);
  }
  return cachedBigInt64Memory02;
}
function makeClosure2(arg0, arg1, dtor, f) {
  const state = { a: arg0, b: arg1, cnt: 1, dtor };
  const real = (...args) => {
    state.cnt++;
    try {
      return f(state.a, state.b, ...args);
    } finally {
      if (--state.cnt === 0) {
        wasm2.__wbindgen_export_2.get(state.dtor)(state.a, state.b);
        state.a = 0;
      }
    }
  };
  real.original = state;
  return real;
}
function __wbg_adapter_48(arg0, arg1) {
  wasm2._dyn_core__ops__function__Fn_____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__ha7dce46ef4419e41(arg0, arg1);
}
function __wbg_adapter_51(arg0, arg1, arg2) {
  wasm2._dyn_core__ops__function__Fn__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__he46328a6ea344717(arg0, arg1, addHeapObject2(arg2));
}
function makeMutClosure2(arg0, arg1, dtor, f) {
  const state = { a: arg0, b: arg1, cnt: 1, dtor };
  const real = (...args) => {
    state.cnt++;
    const a = state.a;
    state.a = 0;
    try {
      return f(a, state.b, ...args);
    } finally {
      if (--state.cnt === 0) {
        wasm2.__wbindgen_export_2.get(state.dtor)(a, state.b);
      } else {
        state.a = a;
      }
    }
  };
  real.original = state;
  return real;
}
function __wbg_adapter_54(arg0, arg1, arg2) {
  wasm2._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__hcbb210081cc80da4(arg0, arg1, addHeapObject2(arg2));
}
function handleError2(f, args) {
  try {
    return f.apply(this, args);
  } catch (e) {
    wasm2.__wbindgen_exn_store(addHeapObject2(e));
  }
}
function __wbg_adapter_101(arg0, arg1, arg2, arg3) {
  wasm2.wasm_bindgen__convert__closures__invoke2_mut__h345f08093c1bd994(arg0, arg1, addHeapObject2(arg2), addHeapObject2(arg3));
}
function notDefined2(what) {
  return () => {
    throw new Error(`${what} is not defined`);
  };
}
var cachedUint32Memory02 = null;
function getUint32Memory02() {
  if (cachedUint32Memory02 === null || cachedUint32Memory02.byteLength === 0) {
    cachedUint32Memory02 = new Uint32Array(wasm2.memory.buffer);
  }
  return cachedUint32Memory02;
}
function getArrayJsValueFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  const mem = getUint32Memory02();
  const slice = mem.subarray(ptr / 4, ptr / 4 + len);
  const result = [];
  for (let i = 0; i < slice.length; i++) {
    result.push(takeObject2(slice[i]));
  }
  return result;
}
function getArrayU8FromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return getUint8Memory02().subarray(ptr / 1, ptr / 1 + len);
}
function _assertClass2(instance, klass) {
  if (!(instance instanceof klass)) {
    throw new Error(`expected instance of ${klass.name}`);
  }
  return instance.ptr;
}
var DocumentReference = class {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(DocumentReference.prototype);
    obj.__wbg_ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm2.__wbg_documentreference_free(ptr);
  }
  /**
  * @returns {number}
  */
  page_total() {
    const ret = wasm2.documentreference_page_total(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
  * @returns {number}
  */
  page_width() {
    const ret = wasm2.documentreference_page_width(this.__wbg_ptr);
    return ret;
  }
  /**
  * @returns {number}
  */
  page_height() {
    const ret = wasm2.documentreference_page_height(this.__wbg_ptr);
    return ret;
  }
};
var TypstCompiler = class {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(TypstCompiler.prototype);
    obj.__wbg_ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm2.__wbg_typstcompiler_free(ptr);
  }
  /**
  */
  reset() {
    wasm2.typstcompiler_reset(this.__wbg_ptr);
  }
  /**
  * @param {string} path
  * @param {string} content
  * @param {boolean} is_main
  * @returns {boolean}
  */
  add_source(path, content, is_main) {
    const ptr0 = passStringToWasm02(path, wasm2.__wbindgen_malloc, wasm2.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN2;
    const ptr1 = passStringToWasm02(content, wasm2.__wbindgen_malloc, wasm2.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN2;
    const ret = wasm2.typstcompiler_add_source(this.__wbg_ptr, ptr0, len0, ptr1, len1, is_main);
    return ret !== 0;
  }
  /**
  * @param {any} snapshot
  * @param {Function} font_cb
  * @returns {DocumentReference}
  */
  load_snapshot(snapshot, font_cb) {
    try {
      const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
      wasm2.typstcompiler_load_snapshot(retptr, this.__wbg_ptr, addHeapObject2(snapshot), addHeapObject2(font_cb));
      var r0 = getInt32Memory02()[retptr / 4 + 0];
      var r1 = getInt32Memory02()[retptr / 4 + 1];
      var r2 = getInt32Memory02()[retptr / 4 + 2];
      if (r2) {
        throw takeObject2(r1);
      }
      return DocumentReference.__wrap(r0);
    } finally {
      wasm2.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * @param {number} idx
  * @param {Uint8Array} buffer
  */
  modify_font_data(idx, buffer) {
    wasm2.typstcompiler_modify_font_data(this.__wbg_ptr, idx, addHeapObject2(buffer));
  }
  /**
  */
  rebuild() {
    wasm2.typstcompiler_rebuild(this.__wbg_ptr);
  }
  /**
  * @returns {(string)[]}
  */
  get_loaded_fonts() {
    try {
      const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
      wasm2.typstcompiler_get_loaded_fonts(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory02()[retptr / 4 + 0];
      var r1 = getInt32Memory02()[retptr / 4 + 1];
      var v1 = getArrayJsValueFromWasm0(r0, r1).slice();
      wasm2.__wbindgen_free(r0, r1 * 4);
      return v1;
    } finally {
      wasm2.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * @param {string} main_file_path
  * @returns {string}
  */
  get_ast(main_file_path) {
    let deferred3_0;
    let deferred3_1;
    try {
      const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm02(main_file_path, wasm2.__wbindgen_malloc, wasm2.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN2;
      wasm2.typstcompiler_get_ast(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getInt32Memory02()[retptr / 4 + 0];
      var r1 = getInt32Memory02()[retptr / 4 + 1];
      var r2 = getInt32Memory02()[retptr / 4 + 2];
      var r3 = getInt32Memory02()[retptr / 4 + 3];
      var ptr2 = r0;
      var len2 = r1;
      if (r3) {
        ptr2 = 0;
        len2 = 0;
        throw takeObject2(r2);
      }
      deferred3_0 = ptr2;
      deferred3_1 = len2;
      return getStringFromWasm02(ptr2, len2);
    } finally {
      wasm2.__wbindgen_add_to_stack_pointer(16);
      wasm2.__wbindgen_free(deferred3_0, deferred3_1, 1);
    }
  }
  /**
  * @param {string} _format
  * @returns {Uint8Array}
  */
  get_artifact(_format) {
    try {
      const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm02(_format, wasm2.__wbindgen_malloc, wasm2.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN2;
      wasm2.typstcompiler_get_artifact(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getInt32Memory02()[retptr / 4 + 0];
      var r1 = getInt32Memory02()[retptr / 4 + 1];
      var r2 = getInt32Memory02()[retptr / 4 + 2];
      var r3 = getInt32Memory02()[retptr / 4 + 3];
      if (r3) {
        throw takeObject2(r2);
      }
      var v2 = getArrayU8FromWasm0(r0, r1).slice();
      wasm2.__wbindgen_free(r0, r1 * 1);
      return v2;
    } finally {
      wasm2.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * @param {string} _main_file_path
  * @returns {DocumentReference}
  */
  compile(_main_file_path) {
    try {
      const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm02(_main_file_path, wasm2.__wbindgen_malloc, wasm2.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN2;
      wasm2.typstcompiler_compile(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getInt32Memory02()[retptr / 4 + 0];
      var r1 = getInt32Memory02()[retptr / 4 + 1];
      var r2 = getInt32Memory02()[retptr / 4 + 2];
      if (r2) {
        throw takeObject2(r1);
      }
      return DocumentReference.__wrap(r0);
    } finally {
      wasm2.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * @param {CanvasRenderingContext2D} canvas
  * @param {DocumentReference} doc
  * @param {number} page_off
  * @param {number} pixel_per_pt
  * @param {string} background_color
  * @returns {Promise<any>}
  */
  render_page_to_canvas(canvas, doc, page_off, pixel_per_pt, background_color) {
    _assertClass2(doc, DocumentReference);
    const ptr0 = passStringToWasm02(background_color, wasm2.__wbindgen_malloc, wasm2.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN2;
    const ret = wasm2.typstcompiler_render_page_to_canvas(this.__wbg_ptr, addHeapObject2(canvas), doc.__wbg_ptr, page_off, pixel_per_pt, ptr0, len0);
    return takeObject2(ret);
  }
};
var TypstCompilerBuilder = class {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(TypstCompilerBuilder.prototype);
    obj.__wbg_ptr = ptr;
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    return ptr;
  }
  free() {
    const ptr = this.__destroy_into_raw();
    wasm2.__wbg_typstcompilerbuilder_free(ptr);
  }
  /**
  */
  constructor() {
    try {
      const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
      wasm2.typstcompilerbuilder_new(retptr);
      var r0 = getInt32Memory02()[retptr / 4 + 0];
      var r1 = getInt32Memory02()[retptr / 4 + 1];
      var r2 = getInt32Memory02()[retptr / 4 + 2];
      if (r2) {
        throw takeObject2(r1);
      }
      return TypstCompilerBuilder.__wrap(r0);
    } finally {
      wasm2.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
  * @param {any} context
  * @param {Function} mtime_fn
  * @param {Function} is_file_fn
  * @param {Function} real_path_fn
  * @param {Function} read_all_fn
  * @returns {Promise<void>}
  */
  set_access_model(context, mtime_fn, is_file_fn, real_path_fn, read_all_fn) {
    const ret = wasm2.typstcompilerbuilder_set_access_model(this.__wbg_ptr, addHeapObject2(context), addHeapObject2(mtime_fn), addHeapObject2(is_file_fn), addHeapObject2(real_path_fn), addHeapObject2(read_all_fn));
    return takeObject2(ret);
  }
  /**
  * @param {Uint8Array} font_buffer
  * @returns {Promise<void>}
  */
  add_raw_font(font_buffer) {
    const ret = wasm2.typstcompilerbuilder_add_raw_font(this.__wbg_ptr, addHeapObject2(font_buffer));
    return takeObject2(ret);
  }
  /**
  * @param {Array<any>} fonts
  * @returns {Promise<void>}
  */
  add_web_fonts(fonts) {
    const ret = wasm2.typstcompilerbuilder_add_web_fonts(this.__wbg_ptr, addHeapObject2(fonts));
    return takeObject2(ret);
  }
  /**
  * @param {any} pack
  * @returns {Promise<void>}
  */
  add_glyph_pack(pack) {
    const ret = wasm2.typstcompilerbuilder_add_glyph_pack(this.__wbg_ptr, addHeapObject2(pack));
    return takeObject2(ret);
  }
  /**
  * @returns {Promise<TypstCompiler>}
  */
  build() {
    const ptr = this.__destroy_into_raw();
    const ret = wasm2.typstcompilerbuilder_build(ptr);
    return takeObject2(ret);
  }
};
async function __wbg_load2(module, imports) {
  if (typeof Response === "function" && module instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === "function") {
      try {
        return await WebAssembly.instantiateStreaming(module, imports);
      } catch (e) {
        if (module.headers.get("Content-Type") != "application/wasm") {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
        } else {
          throw e;
        }
      }
    }
    const bytes = await module.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);
  } else {
    const instance = await WebAssembly.instantiate(module, imports);
    if (instance instanceof WebAssembly.Instance) {
      return { instance, module };
    } else {
      return instance;
    }
  }
}
function __wbg_get_imports2() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbg_new_abda76e883ba8a5f = function() {
    const ret = new Error();
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) {
    const ret = getObject2(arg1).stack;
    const ptr1 = passStringToWasm02(ret, wasm2.__wbindgen_malloc, wasm2.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN2;
    getInt32Memory02()[arg0 / 4 + 1] = len1;
    getInt32Memory02()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) {
    let deferred0_0;
    let deferred0_1;
    try {
      deferred0_0 = arg0;
      deferred0_1 = arg1;
      console.error(getStringFromWasm02(arg0, arg1));
    } finally {
      wasm2.__wbindgen_free(deferred0_0, deferred0_1, 1);
    }
  };
  imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
    takeObject2(arg0);
  };
  imports.wbg.__wbg_get_44be0491f933a435 = function(arg0, arg1) {
    const ret = getObject2(arg0)[arg1 >>> 0];
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_length_fff51ee6522a1a18 = function(arg0) {
    const ret = getObject2(arg0).length;
    return ret;
  };
  imports.wbg.__wbindgen_is_object = function(arg0) {
    const val = getObject2(arg0);
    const ret = typeof val === "object" && val !== null;
    return ret;
  };
  imports.wbg.__wbg_next_526fc47e980da008 = function(arg0) {
    const ret = getObject2(arg0).next;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_is_function = function(arg0) {
    const ret = typeof getObject2(arg0) === "function";
    return ret;
  };
  imports.wbg.__wbg_next_ddb3312ca1c4e32a = function() {
    return handleError2(function(arg0) {
      const ret = getObject2(arg0).next();
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_done_5c1f01fb660d73b5 = function(arg0) {
    const ret = getObject2(arg0).done;
    return ret;
  };
  imports.wbg.__wbg_value_1695675138684bd5 = function(arg0) {
    const ret = getObject2(arg0).value;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_iterator_97f0c81209c6c35a = function() {
    const ret = Symbol.iterator;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_get_97b561fb56f034b5 = function() {
    return handleError2(function(arg0, arg1) {
      const ret = Reflect.get(getObject2(arg0), getObject2(arg1));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_call_cb65541d95d71282 = function() {
    return handleError2(function(arg0, arg1) {
      const ret = getObject2(arg0).call(getObject2(arg1));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm02(arg0, arg1);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_object_clone_ref = function(arg0) {
    const ret = getObject2(arg0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_self_1ff1d729e9aae938 = function() {
    return handleError2(function() {
      const ret = self.self;
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_window_5f4faef6c12b79ec = function() {
    return handleError2(function() {
      const ret = window.window;
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_globalThis_1d39714405582d3c = function() {
    return handleError2(function() {
      const ret = globalThis.globalThis;
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_global_651f05c6a0944d1c = function() {
    return handleError2(function() {
      const ret = global.global;
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbindgen_is_undefined = function(arg0) {
    const ret = getObject2(arg0) === void 0;
    return ret;
  };
  imports.wbg.__wbg_newnoargs_581967eacc0e2604 = function(arg0, arg1) {
    const ret = new Function(getStringFromWasm02(arg0, arg1));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_new_898a68150f225f2e = function() {
    const ret = new Array();
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_set_502d29070ea18557 = function(arg0, arg1, arg2) {
    getObject2(arg0)[arg1 >>> 0] = takeObject2(arg2);
  };
  imports.wbg.__wbg_isArray_4c24b343cb13cfb1 = function(arg0) {
    const ret = Array.isArray(getObject2(arg0));
    return ret;
  };
  imports.wbg.__wbg_push_ca1c26067ef907ac = function(arg0, arg1) {
    const ret = getObject2(arg0).push(getObject2(arg1));
    return ret;
  };
  imports.wbg.__wbg_instanceof_ArrayBuffer_39ac22089b74fddb = function(arg0) {
    let result;
    try {
      result = getObject2(arg0) instanceof ArrayBuffer;
    } catch {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_new_d258248ed531ff54 = function(arg0, arg1) {
    const ret = new Error(getStringFromWasm02(arg0, arg1));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_call_01734de55d61e11d = function() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = getObject2(arg0).call(getObject2(arg1), getObject2(arg2));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_isSafeInteger_bb8e18dd21c97288 = function(arg0) {
    const ret = Number.isSafeInteger(getObject2(arg0));
    return ret;
  };
  imports.wbg.__wbg_instanceof_Object_3daa8298c86298be = function(arg0) {
    let result;
    try {
      result = getObject2(arg0) instanceof Object;
    } catch {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_entries_e51f29c7bba0c054 = function(arg0) {
    const ret = Object.entries(getObject2(arg0));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_new_b51585de1b234aff = function() {
    const ret = new Object();
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_new_43f1b47c28813cbd = function(arg0, arg1) {
    try {
      var state0 = { a: arg0, b: arg1 };
      var cb0 = (arg02, arg12) => {
        const a = state0.a;
        state0.a = 0;
        try {
          return __wbg_adapter_101(a, state0.b, arg02, arg12);
        } finally {
          state0.a = a;
        }
      };
      const ret = new Promise(cb0);
      return addHeapObject2(ret);
    } finally {
      state0.a = state0.b = 0;
    }
  };
  imports.wbg.__wbg_resolve_53698b95aaf7fcf8 = function(arg0) {
    const ret = Promise.resolve(getObject2(arg0));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_then_f7e06ee3c11698eb = function(arg0, arg1) {
    const ret = getObject2(arg0).then(getObject2(arg1));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_then_b2267541e2a73865 = function(arg0, arg1, arg2) {
    const ret = getObject2(arg0).then(getObject2(arg1), getObject2(arg2));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_memory = function() {
    const ret = wasm2.memory;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_buffer_085ec1f694018c4f = function(arg0) {
    const ret = getObject2(arg0).buffer;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_new_8125e318e6245eed = function(arg0) {
    const ret = new Uint8Array(getObject2(arg0));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_set_5cf90238115182c3 = function(arg0, arg1, arg2) {
    getObject2(arg0).set(getObject2(arg1), arg2 >>> 0);
  };
  imports.wbg.__wbg_length_72e2208bbc0efc61 = function(arg0) {
    const ret = getObject2(arg0).length;
    return ret;
  };
  imports.wbg.__wbg_newwithbyteoffsetandlength_6da8e527659b86aa = function(arg0, arg1, arg2) {
    const ret = new Uint8Array(getObject2(arg0), arg1 >>> 0, arg2 >>> 0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_instanceof_Uint8Array_d8d9cb2b8e8ac1d4 = function(arg0) {
    let result;
    try {
      result = getObject2(arg0) instanceof Uint8Array;
    } catch {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_newwithlength_e5d69174d6984cd7 = function(arg0) {
    const ret = new Uint8Array(arg0 >>> 0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_string_get = function(arg0, arg1) {
    const obj = getObject2(arg1);
    const ret = typeof obj === "string" ? obj : void 0;
    var ptr1 = isLikeNone2(ret) ? 0 : passStringToWasm02(ret, wasm2.__wbindgen_malloc, wasm2.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN2;
    getInt32Memory02()[arg0 / 4 + 1] = len1;
    getInt32Memory02()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbg_random_5f61cd0d6777a993 = typeof Math.random == "function" ? Math.random : notDefined2("Math.random");
  imports.wbg.__wbg_stringify_e25465938f3f611f = function() {
    return handleError2(function(arg0) {
      const ret = JSON.stringify(getObject2(arg0));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_set_092e06b0f9d71865 = function() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = Reflect.set(getObject2(arg0), getObject2(arg1), getObject2(arg2));
      return ret;
    }, arguments);
  };
  imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {
    const ret = debugString2(getObject2(arg1));
    const ptr1 = passStringToWasm02(ret, wasm2.__wbindgen_malloc, wasm2.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN2;
    getInt32Memory02()[arg0 / 4 + 1] = len1;
    getInt32Memory02()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbindgen_error_new = function(arg0, arg1) {
    const ret = new Error(getStringFromWasm02(arg0, arg1));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_jsval_loose_eq = function(arg0, arg1) {
    const ret = getObject2(arg0) == getObject2(arg1);
    return ret;
  };
  imports.wbg.__wbindgen_boolean_get = function(arg0) {
    const v = getObject2(arg0);
    const ret = typeof v === "boolean" ? v ? 1 : 0 : 2;
    return ret;
  };
  imports.wbg.__wbindgen_number_get = function(arg0, arg1) {
    const obj = getObject2(arg1);
    const ret = typeof obj === "number" ? obj : void 0;
    getFloat64Memory02()[arg0 / 8 + 1] = isLikeNone2(ret) ? 0 : ret;
    getInt32Memory02()[arg0 / 4 + 0] = !isLikeNone2(ret);
  };
  imports.wbg.__wbindgen_number_new = function(arg0) {
    const ret = arg0;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_getwithrefkey_5e6d9547403deab8 = function(arg0, arg1) {
    const ret = getObject2(arg0)[getObject2(arg1)];
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_set_841ac57cff3d672b = function(arg0, arg1, arg2) {
    getObject2(arg0)[takeObject2(arg1)] = takeObject2(arg2);
  };
  imports.wbg.__wbg_new_f648bc7adcace0bc = function() {
    return handleError2(function() {
      const ret = new DOMParser();
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_parseFromString_3d7be3de8b4c264e = function() {
    return handleError2(function(arg0, arg1, arg2, arg3) {
      const ret = getObject2(arg0).parseFromString(getStringFromWasm02(arg1, arg2), takeObject2(arg3));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_querySelector_52ded52c20e23921 = function() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = getObject2(arg0).querySelector(getStringFromWasm02(arg1, arg2));
      return isLikeNone2(ret) ? 0 : addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_getElementsByTagName_f5ac50391c7f853c = function(arg0, arg1, arg2) {
    const ret = getObject2(arg0).getElementsByTagName(getStringFromWasm02(arg1, arg2));
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_length_b37ae9be90ea7cf5 = function(arg0) {
    const ret = getObject2(arg0).length;
    return ret;
  };
  imports.wbg.__wbg_firstChild_08ce7a229cc70a39 = function(arg0) {
    const ret = getObject2(arg0).firstChild;
    return isLikeNone2(ret) ? 0 : addHeapObject2(ret);
  };
  imports.wbg.__wbg_instanceof_Element_4622f5da1249a3eb = function(arg0) {
    let result;
    try {
      result = getObject2(arg0) instanceof Element;
    } catch {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_getAttribute_3d8fcc9eaea35a17 = function(arg0, arg1, arg2, arg3) {
    const ret = getObject2(arg1).getAttribute(getStringFromWasm02(arg2, arg3));
    var ptr1 = isLikeNone2(ret) ? 0 : passStringToWasm02(ret, wasm2.__wbindgen_malloc, wasm2.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN2;
    getInt32Memory02()[arg0 / 4 + 1] = len1;
    getInt32Memory02()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbg_outerHTML_f7749ceff37b5832 = function(arg0, arg1) {
    const ret = getObject2(arg1).outerHTML;
    const ptr1 = passStringToWasm02(ret, wasm2.__wbindgen_malloc, wasm2.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN2;
    getInt32Memory02()[arg0 / 4 + 1] = len1;
    getInt32Memory02()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbg_instanceof_Window_9029196b662bc42a = function(arg0) {
    let result;
    try {
      result = getObject2(arg0) instanceof Window;
    } catch {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_document_f7ace2b956f30a4f = function(arg0) {
    const ret = getObject2(arg0).document;
    return isLikeNone2(ret) ? 0 : addHeapObject2(ret);
  };
  imports.wbg.__wbg_createElement_4891554b28d3388b = function() {
    return handleError2(function(arg0, arg1, arg2) {
      const ret = getObject2(arg0).createElement(getStringFromWasm02(arg1, arg2));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_instanceof_HtmlImageElement_7654818e144eb606 = function(arg0) {
    let result;
    try {
      result = getObject2(arg0) instanceof HTMLImageElement;
    } catch {
      result = false;
    }
    const ret = result;
    return ret;
  };
  imports.wbg.__wbg_newwithpathstring_8dbb7720cd8901d4 = function() {
    return handleError2(function(arg0, arg1) {
      const ret = new Path2D(getStringFromWasm02(arg0, arg1));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_save_cdcca9591f027e80 = function(arg0) {
    getObject2(arg0).save();
  };
  imports.wbg.__wbg_restore_890c3582852dbadf = function(arg0) {
    getObject2(arg0).restore();
  };
  imports.wbg.__wbg_now_0cfdc90c97d0c24b = function(arg0) {
    const ret = getObject2(arg0).now();
    return ret;
  };
  imports.wbg.__wbg_warn_fb2e68e6e02a4cb1 = function(arg0, arg1) {
    console.warn(getObject2(arg0), getObject2(arg1));
  };
  imports.wbg.__wbg_info_2e30e8204b29d91d = function(arg0) {
    console.info(getObject2(arg0));
  };
  imports.wbg.__wbindgen_is_bigint = function(arg0) {
    const ret = typeof getObject2(arg0) === "bigint";
    return ret;
  };
  imports.wbg.__wbindgen_bigint_get_as_i64 = function(arg0, arg1) {
    const v = getObject2(arg1);
    const ret = typeof v === "bigint" ? v : void 0;
    getBigInt64Memory02()[arg0 / 8 + 1] = isLikeNone2(ret) ? BigInt(0) : ret;
    getInt32Memory02()[arg0 / 4 + 0] = !isLikeNone2(ret);
  };
  imports.wbg.__wbindgen_bigint_from_i64 = function(arg0) {
    const ret = arg0;
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_jsval_eq = function(arg0, arg1) {
    const ret = getObject2(arg0) === getObject2(arg1);
    return ret;
  };
  imports.wbg.__wbindgen_bigint_from_u64 = function(arg0) {
    const ret = BigInt.asUintN(64, arg0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_in = function(arg0, arg1) {
    const ret = getObject2(arg0) in getObject2(arg1);
    return ret;
  };
  imports.wbg.__wbindgen_is_string = function(arg0) {
    const ret = typeof getObject2(arg0) === "string";
    return ret;
  };
  imports.wbg.__wbg_error_cc121a8b7a240029 = function(arg0, arg1, arg2) {
    console.error(getObject2(arg0), getObject2(arg1), getObject2(arg2));
  };
  imports.wbg.__wbg_log_4c205e6fbb25f8c3 = function(arg0, arg1, arg2) {
    console.log(getObject2(arg0), getObject2(arg1), getObject2(arg2));
  };
  imports.wbg.__wbindgen_cb_drop = function(arg0) {
    const obj = takeObject2(arg0).original;
    if (obj.cnt-- == 1) {
      obj.a = 0;
      return true;
    }
    const ret = false;
    return ret;
  };
  imports.wbg.__wbg_typstcompiler_new = function(arg0) {
    const ret = TypstCompiler.__wrap(arg0);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbg_revokeObjectURL_571395bdb196a1de = function() {
    return handleError2(function(arg0, arg1) {
      URL.revokeObjectURL(getStringFromWasm02(arg0, arg1));
    }, arguments);
  };
  imports.wbg.__wbg_setfillStyle_401fa583a1c8863c = function(arg0, arg1) {
    getObject2(arg0).fillStyle = getObject2(arg1);
  };
  imports.wbg.__wbg_fillRect_e285f7b46668b7fa = function(arg0, arg1, arg2, arg3, arg4) {
    getObject2(arg0).fillRect(arg1, arg2, arg3, arg4);
  };
  imports.wbg.__wbg_setTransform_39caea5e97b29f2e = function() {
    return handleError2(function(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
      getObject2(arg0).setTransform(arg1, arg2, arg3, arg4, arg5, arg6);
    }, arguments);
  };
  imports.wbg.__wbg_beginPath_b3943a4f4af02eac = function(arg0) {
    getObject2(arg0).beginPath();
  };
  imports.wbg.__wbg_fill_4fbbfcd27461f1e6 = function(arg0, arg1) {
    getObject2(arg0).fill(getObject2(arg1));
  };
  imports.wbg.__wbg_resetTransform_8427c5468207dba3 = function() {
    return handleError2(function(arg0) {
      getObject2(arg0).resetTransform();
    }, arguments);
  };
  imports.wbg.__wbg_transform_c9f55f741f6615bf = function() {
    return handleError2(function(arg0, arg1, arg2, arg3, arg4, arg5, arg6) {
      getObject2(arg0).transform(arg1, arg2, arg3, arg4, arg5, arg6);
    }, arguments);
  };
  imports.wbg.__wbg_setlineDashOffset_f37f4ea2fc9ddee1 = function(arg0, arg1) {
    getObject2(arg0).lineDashOffset = arg1;
  };
  imports.wbg.__wbg_setLineDash_ffd4b25a7a33e57b = function() {
    return handleError2(function(arg0, arg1) {
      getObject2(arg0).setLineDash(getObject2(arg1));
    }, arguments);
  };
  imports.wbg.__wbg_setlineWidth_6cbd15cb2b4ab14b = function(arg0, arg1) {
    getObject2(arg0).lineWidth = arg1;
  };
  imports.wbg.__wbg_setlineCap_6ebf29df37947b53 = function(arg0, arg1, arg2) {
    getObject2(arg0).lineCap = getStringFromWasm02(arg1, arg2);
  };
  imports.wbg.__wbg_setlineJoin_eccaea89d57fb044 = function(arg0, arg1, arg2) {
    getObject2(arg0).lineJoin = getStringFromWasm02(arg1, arg2);
  };
  imports.wbg.__wbg_setmiterLimit_50d0d46f19e3054f = function(arg0, arg1) {
    getObject2(arg0).miterLimit = arg1;
  };
  imports.wbg.__wbg_setstrokeStyle_3fe4d1c0d11ed1b6 = function(arg0, arg1) {
    getObject2(arg0).strokeStyle = getObject2(arg1);
  };
  imports.wbg.__wbg_stroke_c4647eb26598b90b = function(arg0, arg1) {
    getObject2(arg0).stroke(getObject2(arg1));
  };
  imports.wbg.__wbg_clip_aa52b99fb9d275fb = function(arg0, arg1) {
    getObject2(arg0).clip(getObject2(arg1));
  };
  imports.wbg.__wbg_canvas_d018466af7372650 = function(arg0) {
    const ret = getObject2(arg0).canvas;
    return isLikeNone2(ret) ? 0 : addHeapObject2(ret);
  };
  imports.wbg.__wbg_setAttribute_e7e80b478b7b8b2f = function() {
    return handleError2(function(arg0, arg1, arg2, arg3, arg4) {
      getObject2(arg0).setAttribute(getStringFromWasm02(arg1, arg2), getStringFromWasm02(arg3, arg4));
    }, arguments);
  };
  imports.wbg.__wbg_newwithu8arraysequenceandoptions_854056d2c35b489c = function() {
    return handleError2(function(arg0, arg1) {
      const ret = new Blob(getObject2(arg0), getObject2(arg1));
      return addHeapObject2(ret);
    }, arguments);
  };
  imports.wbg.__wbg_createObjectURL_d82f2880bada6a1d = function() {
    return handleError2(function(arg0, arg1) {
      const ret = URL.createObjectURL(getObject2(arg1));
      const ptr1 = passStringToWasm02(ret, wasm2.__wbindgen_malloc, wasm2.__wbindgen_realloc);
      const len1 = WASM_VECTOR_LEN2;
      getInt32Memory02()[arg0 / 4 + 1] = len1;
      getInt32Memory02()[arg0 / 4 + 0] = ptr1;
    }, arguments);
  };
  imports.wbg.__wbg_drawImage_91b0b71585865ad1 = function() {
    return handleError2(function(arg0, arg1, arg2, arg3, arg4, arg5) {
      getObject2(arg0).drawImage(getObject2(arg1), arg2, arg3, arg4, arg5);
    }, arguments);
  };
  imports.wbg.__wbg_setsrc_fac5b9516fc69301 = function(arg0, arg1, arg2) {
    getObject2(arg0).src = getStringFromWasm02(arg1, arg2);
  };
  imports.wbg.__wbg_setonload_b4f5d9b15b0ee9d3 = function(arg0, arg1) {
    getObject2(arg0).onload = getObject2(arg1);
  };
  imports.wbg.__wbg_setonerror_acddd28c276005c1 = function(arg0, arg1) {
    getObject2(arg0).onerror = getObject2(arg1);
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm02(arg0, arg1));
  };
  imports.wbg.__wbindgen_closure_wrapper10393 = function(arg0, arg1, arg2) {
    const ret = makeClosure2(arg0, arg1, 3339, __wbg_adapter_48);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper10394 = function(arg0, arg1, arg2) {
    const ret = makeClosure2(arg0, arg1, 3339, __wbg_adapter_51);
    return addHeapObject2(ret);
  };
  imports.wbg.__wbindgen_closure_wrapper11380 = function(arg0, arg1, arg2) {
    const ret = makeMutClosure2(arg0, arg1, 3566, __wbg_adapter_54);
    return addHeapObject2(ret);
  };
  return imports;
}
function __wbg_init_memory2(imports, maybe_memory) {
}
function __wbg_finalize_init2(instance, module) {
  wasm2 = instance.exports;
  __wbg_init2.__wbindgen_wasm_module = module;
  cachedBigInt64Memory02 = null;
  cachedFloat64Memory02 = null;
  cachedInt32Memory02 = null;
  cachedUint32Memory02 = null;
  cachedUint8Memory02 = null;
  return wasm2;
}
async function __wbg_init2(input) {
  if (wasm2 !== void 0)
    return wasm2;
  if (typeof input === "undefined") {
    input = new URL("typst_ts_web_compiler_bg.wasm", import.meta.url);
  }
  const imports = __wbg_get_imports2();
  if (typeof input === "string" || typeof Request === "function" && input instanceof Request || typeof URL === "function" && input instanceof URL) {
    input = fetch(input);
  }
  __wbg_init_memory2(imports);
  const { instance, module } = await __wbg_load2(await input, imports);
  return __wbg_finalize_init2(instance, module);
}
var typst_ts_web_compiler_default = __wbg_init2;

// ../../node_modules/idb/build/wrap-idb-value.js
var instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);
var idbProxyableTypes;
var cursorAdvanceMethods;
function getIdbProxyableTypes() {
  return idbProxyableTypes || (idbProxyableTypes = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function getCursorAdvanceMethods() {
  return cursorAdvanceMethods || (cursorAdvanceMethods = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
var cursorRequestMap = /* @__PURE__ */ new WeakMap();
var transactionDoneMap = /* @__PURE__ */ new WeakMap();
var transactionStoreNamesMap = /* @__PURE__ */ new WeakMap();
var transformCache = /* @__PURE__ */ new WeakMap();
var reverseTransformCache = /* @__PURE__ */ new WeakMap();
function promisifyRequest(request) {
  const promise = new Promise((resolve, reject) => {
    const unlisten = () => {
      request.removeEventListener("success", success);
      request.removeEventListener("error", error);
    };
    const success = () => {
      resolve(wrap(request.result));
      unlisten();
    };
    const error = () => {
      reject(request.error);
      unlisten();
    };
    request.addEventListener("success", success);
    request.addEventListener("error", error);
  });
  promise.then((value) => {
    if (value instanceof IDBCursor) {
      cursorRequestMap.set(value, request);
    }
  }).catch(() => {
  });
  reverseTransformCache.set(promise, request);
  return promise;
}
function cacheDonePromiseForTransaction(tx) {
  if (transactionDoneMap.has(tx))
    return;
  const done = new Promise((resolve, reject) => {
    const unlisten = () => {
      tx.removeEventListener("complete", complete);
      tx.removeEventListener("error", error);
      tx.removeEventListener("abort", error);
    };
    const complete = () => {
      resolve();
      unlisten();
    };
    const error = () => {
      reject(tx.error || new DOMException("AbortError", "AbortError"));
      unlisten();
    };
    tx.addEventListener("complete", complete);
    tx.addEventListener("error", error);
    tx.addEventListener("abort", error);
  });
  transactionDoneMap.set(tx, done);
}
var idbProxyTraps = {
  get(target, prop, receiver) {
    if (target instanceof IDBTransaction) {
      if (prop === "done")
        return transactionDoneMap.get(target);
      if (prop === "objectStoreNames") {
        return target.objectStoreNames || transactionStoreNamesMap.get(target);
      }
      if (prop === "store") {
        return receiver.objectStoreNames[1] ? void 0 : receiver.objectStore(receiver.objectStoreNames[0]);
      }
    }
    return wrap(target[prop]);
  },
  set(target, prop, value) {
    target[prop] = value;
    return true;
  },
  has(target, prop) {
    if (target instanceof IDBTransaction && (prop === "done" || prop === "store")) {
      return true;
    }
    return prop in target;
  }
};
function replaceTraps(callback) {
  idbProxyTraps = callback(idbProxyTraps);
}
function wrapFunction(func) {
  if (func === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype)) {
    return function(storeNames, ...args) {
      const tx = func.call(unwrap(this), storeNames, ...args);
      transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);
      return wrap(tx);
    };
  }
  if (getCursorAdvanceMethods().includes(func)) {
    return function(...args) {
      func.apply(unwrap(this), args);
      return wrap(cursorRequestMap.get(this));
    };
  }
  return function(...args) {
    return wrap(func.apply(unwrap(this), args));
  };
}
function transformCachableValue(value) {
  if (typeof value === "function")
    return wrapFunction(value);
  if (value instanceof IDBTransaction)
    cacheDonePromiseForTransaction(value);
  if (instanceOfAny(value, getIdbProxyableTypes()))
    return new Proxy(value, idbProxyTraps);
  return value;
}
function wrap(value) {
  if (value instanceof IDBRequest)
    return promisifyRequest(value);
  if (transformCache.has(value))
    return transformCache.get(value);
  const newValue = transformCachableValue(value);
  if (newValue !== value) {
    transformCache.set(value, newValue);
    reverseTransformCache.set(newValue, value);
  }
  return newValue;
}
var unwrap = (value) => reverseTransformCache.get(value);

// ../../node_modules/idb/build/index.js
var readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"];
var writeMethods = ["put", "add", "delete", "clear"];
var cachedMethods = /* @__PURE__ */ new Map();
function getMethod(target, prop) {
  if (!(target instanceof IDBDatabase && !(prop in target) && typeof prop === "string")) {
    return;
  }
  if (cachedMethods.get(prop))
    return cachedMethods.get(prop);
  const targetFuncName = prop.replace(/FromIndex$/, "");
  const useIndex = prop !== targetFuncName;
  const isWrite = writeMethods.includes(targetFuncName);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) || !(isWrite || readMethods.includes(targetFuncName))
  ) {
    return;
  }
  const method = async function(storeName, ...args) {
    const tx = this.transaction(storeName, isWrite ? "readwrite" : "readonly");
    let target2 = tx.store;
    if (useIndex)
      target2 = target2.index(args.shift());
    return (await Promise.all([
      target2[targetFuncName](...args),
      isWrite && tx.done
    ]))[0];
  };
  cachedMethods.set(prop, method);
  return method;
}
replaceTraps((oldTraps) => ({
  ...oldTraps,
  get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),
  has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop)
}));

// src/init.ts
var globalFontPromises = [];
var ComponentBuilder = class {
  async loadFont(builder, fontPath) {
    const response = await fetch(fontPath);
    const fontBuffer = new Uint8Array(await response.arrayBuffer());
    await builder.add_raw_font(fontBuffer);
  }
  async build(options, builder, hooks) {
    const buildCtx = { ref: this, builder, hooks };
    for (const fn of options?.beforeBuild ?? []) {
      await fn(void 0, buildCtx);
    }
    if (hooks.latelyBuild) {
      hooks.latelyBuild(buildCtx);
    }
    const component = await builder.build();
    return component;
  }
};
async function buildComponent(options, gModule, Builder, hooks) {
  if (options?.getModule) {
    await gModule.init(options.getModule());
  }
  return await new ComponentBuilder().build(options, new Builder(), hooks);
}

// src/renderer.ts
var gRendererModule = new LazyWasmModule(typst_ts_renderer_default);
function createTypstRenderer(pdf) {
  return new TypstRendererDriver(pdf);
}
function createTypstSvgRenderer() {
  return new TypstRendererSvgDriver();
}
function rendererBuildInfo() {
  return renderer_build_info();
}
function randstr(prefix) {
  return Math.random().toString(36).replace("0.", prefix || "");
}
var TypstRendererSvgDriver = class {
  constructor() {
  }
  async init(options) {
    this.renderer = await buildComponent(options, gRendererModule, TypstRendererBuilder, {});
  }
  createModule(b) {
    return new Promise((resolve) => {
      resolve(b ? this.renderer.create_svg_session(b) : this.renderer.create_empty_svg_session());
    });
  }
  renderSvg(session, container) {
    return new Promise((resolve) => {
      resolve(this.renderer.render_svg(session, container));
    });
  }
};
var TypstRendererDriver = class {
  constructor(pdf) {
    this.pdf = pdf;
  }
  async init(options) {
    this.renderer = await buildComponent(options, gRendererModule, TypstRendererBuilder, {});
  }
  loadGlyphPack(pack) {
    this.renderer.load_glyph_pack(pack);
    return Promise.resolve();
  }
  artifactOptionsToRust(options) {
    const rustOptions = new RenderSessionOptions();
    rustOptions.pixel_per_pt = options.pixelPerPt ?? 2;
    if (options.backgroundColor !== void 0) {
      if (!/^#[0-9a-f]{6}$/.test(options.backgroundColor)) {
        throw new Error(
          "Invalid typst.RenderOptions.backgroundColor color for matching ^#[0-9a-f]{6}$ " + options.backgroundColor
        );
      }
      rustOptions.background_color = options.backgroundColor.slice(1);
    }
    if (options.format !== void 0) {
      rustOptions.format = options.format;
    }
    return rustOptions;
  }
  loadPagesInfo(session, options) {
    const pages_info = session.pages_info;
    const pageInfos = [];
    const pageCount = pages_info.page_count;
    for (let i = 0; i < pageCount; i++) {
      const pageAst = pages_info.page(i);
      pageInfos.push({
        pageOffset: pageAst.page_off,
        width: pageAst.width_pt,
        height: pageAst.height_pt
      });
    }
    return pageInfos;
  }
  renderImageInSession(session, canvas, options) {
    if (!options) {
      return this.renderer.render_page_to_canvas(session, canvas);
    }
    const rustOptions = new RenderPageImageOptions();
    rustOptions.page_off = options.page_off;
    return this.renderer.render_page_to_canvas(session, canvas, rustOptions);
  }
  // async renderPdf(artifactContent: string): Promise<Uint8Array> {
  // return this.renderer.render_to_pdf(artifactContent);
  // }
  //
  // async renderPdfInSession(session: RenderSession): Promise<Uint8Array> {
  // return this.renderer.render_to_pdf_in_session(session as typst.RenderSession);
  // }
  async inAnimationFrame(fn) {
    return new Promise((resolve, reject) => {
      requestAnimationFrame(() => {
        try {
          resolve(fn());
        } catch (e) {
          reject(e);
        }
      });
    });
  }
  async renderDisplayLayer(session, container, canvasList, options) {
    const pages_info = session.pages_info;
    const page_count = pages_info.page_count;
    let renderResult = void 0;
    const doRender = async (i, page_off) => {
      const canvas = canvasList[i];
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        throw new Error("canvas context is null");
      }
      const res = await this.renderImageInSession(session, ctx, {
        page_off
      });
      if (i === 0) {
        renderResult = {
          width: canvas.width,
          height: canvas.height
        };
      }
      return res;
    };
    return this.inAnimationFrame(async () => {
      const t = performance.now();
      const textContentList = (await Promise.all(
        //   canvasList.map(async (canvas, i) => {
        //     const renderResult = await this.renderImageInSession(session, {
        //       page_off: i,
        //     });
        //     console.log(cyrb53(renderResult.data));
        //     let ctx = canvas.getContext('2d');
        //     if (ctx) {
        //       ctx.putImageData(renderResult, 0, 0);
        //     }
        //     return {
        //       width: renderResult.width,
        //       height: renderResult.height,
        //     };
        //   }),
        // )
        /// seq
        [
          (async () => {
            const results = [];
            for (let i = 0; i < page_count; i++) {
              results.push(await doRender(i, i));
            }
            return results;
          })()
        ]
      ))[0];
      const t3 = performance.now();
      console.log(`display layer used: render = ${(t3 - t).toFixed(1)}ms`);
      return [renderResult, textContentList];
    });
  }
  renderOnePageTextLayer(container, viewport, textContentSource) {
    this.pdf.renderTextLayer({
      textContentSource,
      container,
      viewport
    });
  }
  renderTextLayer(session, view, container, layerList, textSourceList) {
    renderTextLayer(this.pdf, container, view.pageInfos, layerList, textSourceList);
  }
  renderAnnotationLayer(_session, view, _container, layerList, annotationSourceList) {
    const pageInfos = view.pageInfos;
    const t2 = performance.now();
    const renderOne = (layer, i) => {
      const page_info = pageInfos[i];
      if (!page_info) {
        console.error("page not found for", i);
        return;
      }
      const width_pt = page_info.width;
      const height_pt = page_info.height;
      layer.innerHTML = "";
      for (const lnk of annotationSourceList[i].links) {
        const annotationBox = document.createElement("div");
        const x = lnk.annotation_box.transform[4] / width_pt * 100;
        const y = lnk.annotation_box.transform[5] / height_pt * 100;
        const skewY = lnk.annotation_box.transform[1];
        const skewX = lnk.annotation_box.transform[2];
        annotationBox.className = "typst-annotation";
        annotationBox.style.width = `${lnk.annotation_box.width / width_pt * 100}%`;
        annotationBox.style.height = `${lnk.annotation_box.height / height_pt * 100}%`;
        annotationBox.style.left = `${x}%`;
        annotationBox.style.top = `${y}%`;
        annotationBox.style.transform = `matrix(1, ${skewY}, ${skewX}, 1, 0, 0)`;
        switch (lnk.action.t) {
          case "Url": {
            const a = document.createElement("a");
            a.href = lnk.action.v.url;
            a.target = "_blank";
            a.appendChild(annotationBox);
            layer.appendChild(a);
            break;
          }
          case "GoTo": {
            const destPoint = document.createElement("div");
            destPoint.className = "typst-annotation";
            const destX = lnk.action.v.x / width_pt * 100;
            const destY = lnk.action.v.y / height_pt * 100;
            destPoint.style.left = `${destX}%`;
            destPoint.style.top = `${destY}%`;
            const destId = randstr("lnk-");
            destPoint.id = destId;
            const destLayer = layerList[lnk.action.v.page_ref - 1];
            destLayer.appendChild(destPoint);
            const a = document.createElement("a");
            a.href = `#${destId}`;
            a.appendChild(annotationBox);
            layer.appendChild(a);
            break;
          }
          default:
            console.warn("unknown action", lnk);
            break;
        }
      }
    };
    layerList.forEach(renderOne);
    const t3 = performance.now();
    console.log(`annotation layer used: render = ${(t3 - t2).toFixed(1)}ms`);
  }
  async renderArtifact(options) {
    let session;
    let renderResult;
    let renderPageResults;
    const mountContainer = options.container;
    mountContainer.style.visibility = "hidden";
    const doRenderDisplayLayer = async (canvasList, resetLayout) => {
      try {
        [renderResult, renderPageResults] = await this.renderDisplayLayer(
          session,
          mountContainer,
          canvasList,
          options
        );
        resetLayout();
      } finally {
        mountContainer.style.visibility = "visible";
      }
    };
    return this.withinOptionSession(options, async (sessionRef) => {
      session = sessionRef;
      if (session.pages_info.page_count === 0) {
        throw new Error(`No page found in session`);
      }
      const t = performance.now();
      const pageView = new RenderView(
        this.loadPagesInfo(session, options),
        mountContainer,
        options
      );
      const t2 = performance.now();
      console.log(`layer used: retieve = ${(t2 - t).toFixed(1)}ms`);
      await doRenderDisplayLayer(pageView.canvasList, () => pageView.resetLayout());
      this.renderTextLayer(
        session,
        pageView,
        mountContainer,
        pageView.textLayerList,
        renderPageResults.map((r) => r.textContent)
      );
      this.renderAnnotationLayer(
        session,
        pageView,
        mountContainer,
        pageView.annotationLayerList,
        renderPageResults.map((r) => r.annotationList)
      );
      return renderResult;
    });
  }
  async renderSvg(options) {
    throw new Error("unimplemented");
  }
  async render(options) {
    if (isRenderSvgOption(options)) {
      return this.renderSvg(options);
    } else {
      return this.renderArtifact(options);
    }
  }
  withinOptionSession(options, fn) {
    if ("renderSession" in options) {
      return fn(options.renderSession);
    }
    function isRenderByContentOption(options2) {
      return "artifactContent" in options2;
    }
    if (isRenderByContentOption(options)) {
      return this.runWithSession(options, fn);
    }
    throw new Error(
      "Invalid render options, should be one of RenderByContentOptions|RenderBySessionOptions"
    );
  }
  async runWithSession(options, fn) {
    const session = isRenderSvgOption(options) ? options.artifactContent ? this.renderer.create_svg_session(options.artifactContent) : this.renderer.create_empty_svg_session() : this.renderer.create_session(
      options.artifactContent,
      /* moved */
      this.artifactOptionsToRust(options)
    );
    try {
      const res = await fn(session);
      session.free();
      return res;
    } catch (e) {
      session.free();
      throw e;
    }
  }
};

// src/compiler.ts
var gCompilerModule = new LazyWasmModule(typst_ts_web_compiler_default);
function createTypstCompiler() {
  return new TypstCompilerDriver();
}
var TypstCompilerDriver = class {
  constructor() {
  }
  async init(options) {
    this.compiler = await buildComponent(options, gCompilerModule, TypstCompilerBuilder, {});
  }
  async runSyncCodeUntilStable(execute) {
    for (; ; ) {
      console.log(this.compiler.get_loaded_fonts());
      const result = execute();
      console.log(this.compiler.get_loaded_fonts());
      if (globalFontPromises.length > 0) {
        const promises = Promise.all(globalFontPromises.splice(0, globalFontPromises.length));
        const callbacks = await promises;
        for (const callback of callbacks) {
          this.compiler.modify_font_data(callback.idx, new Uint8Array(callback.buffer));
        }
        this.compiler.rebuild();
        continue;
      }
      return result;
    }
  }
  async reset() {
    await new Promise((resolve) => {
      this.compiler.reset();
      resolve(void 0);
    });
  }
  loadSnapshot(snapshot, fontServer) {
    return new Promise((resolve) => {
      resolve(this.compiler.load_snapshot(snapshot, (p) => fontServer.readAll(p)));
    });
  }
  async addSource(path, source, isMain) {
    await new Promise((resolve) => {
      this.compiler.add_source(path, source, isMain);
      resolve(void 0);
    });
  }
  async getAst(mainFilePath) {
    return this.runSyncCodeUntilStable(() => this.compiler.get_ast(mainFilePath));
  }
  compile(options) {
    return new Promise((resolve) => {
      const data = this.compiler.compile(options.mainFilePath);
      resolve(data);
    });
  }
  renderPageToCanvas(canvas, doc, page_off, pixel_per_pt, background_color) {
    return this.compiler.render_page_to_canvas(
      canvas,
      doc,
      page_off,
      pixel_per_pt,
      background_color
    );
  }
};

// src/fs/fetch.ts
var bufferToBase64 = async (data) => {
  const base64url = await new Promise((r, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      const result = reader.result;
      if (typeof result === "string" || result === null) {
        r(result);
      }
      reject(new Error("Unexpected result type"));
    };
    reader.readAsDataURL(new Blob([data], { type: "application/octet-binary" }));
  });
  return base64url || "";
};
var FetchAccessModel = class {
  constructor(root, options) {
    this.root = root;
    this.mTimes = /* @__PURE__ */ new Map();
    this.mRealPaths = /* @__PURE__ */ new Map();
    this.mData = /* @__PURE__ */ new Map();
    if (root.endsWith("/")) {
      this.root = this.root.slice(0, this.root.length - 1);
    }
    if (options?.polyfillHeadRequest) {
    }
    this.fullyCached = !!options?.fullyCached;
  }
  reset() {
    this.mTimes.clear();
    this.mRealPaths.clear();
    this.mData.clear();
  }
  resolvePath(path) {
    return this.root + path;
  }
  async loadSnapshot(snapshot) {
    async function base64UrlToBuffer(base64Url) {
      const res = await fetch(base64Url);
      const buffer = await res.arrayBuffer();
      return new Uint8Array(buffer);
    }
    this.root = snapshot.root;
    snapshot.mTimes.forEach((v, k) => this.mTimes.set(k, v ? new Date(v) : void 0));
    this.mRealPaths = new Map(snapshot.mRealPaths);
    await Promise.all(
      snapshot.mData.map(async ([k, v]) => {
        if (typeof v == "string" && v.startsWith("data:")) {
          this.mData.set(k, await base64UrlToBuffer(v));
        } else if (v instanceof Uint8Array) {
          this.mData.set(k, v);
        } else {
          this.mData.set(k, void 0);
        }
      })
    );
  }
  async exportSnapshot() {
    const snapshot = [];
    snapshot.push("((() => {");
    snapshot.push(
      `const snapshot = {  root: '', mTimes: new Map(),  mRealPaths: new Map(),  mData: [],};`
    );
    snapshot.push(`snapshot.root = ${JSON.stringify(this.root)};`);
    snapshot.push(
      `snapshot.mTimes = new Map([${[...this.mTimes.entries()].map(([k, v]) => `[${JSON.stringify(k)}, ${v?.getTime() || "undefined"}]`).join(", ")}]);`
    );
    snapshot.push(
      `snapshot.mRealPaths = new Map([${[...this.mRealPaths.entries()].map(([k, v]) => `[${JSON.stringify(k)}, ${JSON.stringify(v)}]`).join(", ")}]);`
    );
    const dataEntries = await Promise.all(
      [...this.mData.entries()].map(
        async ([k, v]) => v ? `[${JSON.stringify(k)}, "${await bufferToBase64(v)}"]` : `[${JSON.stringify(k)}, undefined}]`
      )
    );
    snapshot.push(`snapshot.mData = [${dataEntries.join(", ")}];`);
    snapshot.push(`return snapshot;`);
    snapshot.push("})())");
    return snapshot.join("\n");
  }
  async getPreloadScript() {
    const snapshot = [];
    snapshot.push("((async () => {");
    snapshot.push(
      `const snapshot = {  root: '', mTimes: new Map(),  mRealPaths: new Map(),  mData: [],};`
    );
    snapshot.push(`const runFetch = async (path) => {`);
    snapshot.push(`  const res = await fetch(snapshot.root + path);`);
    snapshot.push(`  const buffer = await res.arrayBuffer();`);
    snapshot.push(`  return [path, new Uint8Array(buffer)];`);
    snapshot.push(`};`);
    snapshot.push(`snapshot.root = ${JSON.stringify(this.root)};`);
    snapshot.push(
      `snapshot.mTimes = new Map([${[...this.mTimes.entries()].map(([k, v]) => `[${JSON.stringify(k)}, ${v?.getTime() || "undefined"}]`).join(", ")}]);`
    );
    snapshot.push(
      `snapshot.mRealPaths = new Map([${[...this.mRealPaths.entries()].map(([k, v]) => `[${JSON.stringify(k)}, ${JSON.stringify(v)}]`).join(", ")}]);`
    );
    const dataEntries = await Promise.all(
      [...this.mData.entries()].map(async ([k, v]) => {
        k = JSON.stringify(k);
        return v ? `runFetch(${k})` : `Promise.resolve([${k}, undefined])`;
      })
    );
    snapshot.push(`snapshot.mData = await Promise.all([${dataEntries.join(", ")}]);`);
    snapshot.push(`return snapshot;`);
    snapshot.push("})())");
    return snapshot.join("\n");
  }
  getLastModified(path) {
    const request = new XMLHttpRequest();
    request.open("HEAD", path, false);
    request.send(null);
    if (request.status === 200) {
      return request.getResponseHeader("Last-Modified");
    }
    return null;
  }
  getMTimeInternal(path) {
    const lastModified = this.getLastModified(this.resolvePath(path));
    if (lastModified) {
      return new Date(lastModified);
    }
    return void 0;
  }
  getMTime(path) {
    if (!this.fullyCached) {
      return this.getMTimeInternal(path);
    }
    if (this.mTimes.has(path)) {
      return this.mTimes.get(path);
    }
    const mTime = this.getMTimeInternal(path);
    this.mTimes.set(path, mTime);
    return mTime;
  }
  // todo: isFile
  isFile() {
    return true;
  }
  // todo: getRealPath
  getRealPath(path) {
    return path;
  }
  readAllInternal(path) {
    const request = new XMLHttpRequest();
    request.overrideMimeType("text/plain; charset=x-user-defined");
    request.open("GET", this.resolvePath(path), false);
    request.send(null);
    if (request.status === 200 && (request.response instanceof String || typeof request.response === "string")) {
      return Uint8Array.from(request.response, (c) => c.charCodeAt(0));
    }
    return void 0;
  }
  readAll(path) {
    if (!this.fullyCached) {
      return this.readAllInternal(path);
    }
    if (this.mData.has(path)) {
      return this.mData.get(path);
    }
    const data = this.readAllInternal(path);
    this.mData.set(path, data);
    return data;
  }
};

// src/main.ts
if (window) {
  window.TypstRenderModule = {
    RenderView,
    renderTextLayer,
    createTypstRenderer,
    createTypstSvgRenderer,
    preloadRemoteFonts,
    preloadSystemFonts
  };
  window.TypstCompileModule = {
    createTypstCompiler,
    preloadRemoteFonts,
    preloadSystemFonts,
    FetchAccessModel,
    withAccessModel
  };
}
export {
  FetchAccessModel,
  createTypstCompiler,
  createTypstRenderer,
  createTypstSvgRenderer,
  preloadRemoteFonts,
  preloadSystemFonts,
  rendererBuildInfo
};
